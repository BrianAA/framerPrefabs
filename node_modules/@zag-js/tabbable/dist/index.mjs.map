{"version":3,"sources":["../src/proxy-tab-focus.ts","../src/shared.ts","../src/focusable.ts","../src/tabbable.ts"],"sourcesContent":["import { raf } from \"@zag-js/dom-query\"\nimport { getNextTabbable, getTabbableEdges } from \"./tabbable\"\n\ntype MaybeElement = HTMLElement | null\ntype NodeOrFn = MaybeElement | (() => MaybeElement)\n\ninterface ProxyTabFocusOptions<T = MaybeElement> {\n  triggerElement?: T\n  onFocus?: (elementToFocus: HTMLElement) => void\n  defer?: boolean\n}\n\n/**\n * Proxies tab focus within a container to a reference element\n * when the container is rendered in a portal\n */\n\nfunction proxyTabFocusImpl(container: MaybeElement, options: ProxyTabFocusOptions = {}) {\n  const { triggerElement, onFocus } = options\n\n  const doc = container?.ownerDocument || document\n  const body = doc.body\n\n  function onKeyDown(event: KeyboardEvent) {\n    if (event.key !== \"Tab\") return\n\n    let elementToFocus: MaybeElement | undefined = null\n\n    // get all tabbable elements within the container\n    const [firstTabbable, lastTabbable] = getTabbableEdges(container, true)\n\n    const noTabbableElements = !firstTabbable && !lastTabbable\n\n    // if we're focused on the first tabbable element and the user tabs backwards\n    // we want to focus the reference element\n    if (event.shiftKey && (doc.activeElement === firstTabbable || noTabbableElements)) {\n      elementToFocus = triggerElement\n    } else if (!event.shiftKey && doc.activeElement === triggerElement) {\n      // if we're focused on the reference element and the user tabs forwards\n      // we want to focus the first tabbable element\n      elementToFocus = firstTabbable\n    } else if (!event.shiftKey && (doc.activeElement === lastTabbable || noTabbableElements)) {\n      // if we're focused on the last tabbable element and the user tabs forwards\n      // we want to focus the next tabbable element after the reference element\n      elementToFocus = getNextTabbable(body, triggerElement)\n    }\n\n    if (!elementToFocus) return\n\n    event.preventDefault()\n\n    onFocus?.(elementToFocus) ?? elementToFocus.focus()\n  }\n\n  // listen for the tab key in the capture phase\n  doc?.addEventListener(\"keydown\", onKeyDown, true)\n\n  return () => {\n    doc?.removeEventListener(\"keydown\", onKeyDown, true)\n  }\n}\n\nexport function proxyTabFocus(container: NodeOrFn, options: ProxyTabFocusOptions<NodeOrFn>) {\n  const { defer, triggerElement, ...restOptions } = options\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const node = typeof container === \"function\" ? container() : container\n      const trigger = typeof triggerElement === \"function\" ? triggerElement() : triggerElement\n      cleanups.push(proxyTabFocusImpl(node, { triggerElement: trigger, ...restOptions }))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n","export const isHTMLElement = (element: any): element is HTMLElement =>\n  typeof element === \"object\" && element !== null && element.nodeType === 1\n\nexport const isFrame = (element: any): element is HTMLIFrameElement =>\n  isHTMLElement(element) && element.tagName === \"IFRAME\"\n\nexport function isVisible(el: any) {\n  if (!isHTMLElement(el)) return false\n  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0\n}\n\nexport type IncludeContainerType = boolean | \"if-empty\"\n\nexport function hasNegativeTabIndex(element: Element) {\n  const tabIndex = parseInt(element.getAttribute(\"tabindex\") || \"0\", 10)\n  return tabIndex < 0\n}\n\nexport const focusableSelector =\n  /*#__PURE__*/ \"input:not([type='hidden']):not([disabled]), select:not([disabled]), \" +\n  \"textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], \" +\n  \"iframe, object, embed, area[href], audio[controls], video[controls], \" +\n  \"[contenteditable]:not([contenteditable='false']), details > summary:first-of-type\"\n","import { focusableSelector, isFrame, isHTMLElement, isVisible, type IncludeContainerType } from \"./shared\"\n\n/**\n * Returns the focusable elements within the element\n */\n\nexport const getFocusables = (\n  container: Pick<HTMLElement, \"querySelectorAll\"> | null,\n  includeContainer: IncludeContainerType = false,\n) => {\n  if (!container) return []\n  const elements = Array.from(container.querySelectorAll<HTMLElement>(focusableSelector))\n\n  const include = includeContainer == true || (includeContainer == \"if-empty\" && elements.length === 0)\n  if (include && isHTMLElement(container) && isFocusable(container)) {\n    elements.unshift(container)\n  }\n\n  const focusableElements = elements.filter(isFocusable)\n\n  focusableElements.forEach((element, i) => {\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body\n      focusableElements.splice(i, 1, ...getFocusables(frameBody))\n    }\n  })\n\n  return focusableElements\n}\n/**\n * Whether this element is focusable\n */\n\nexport function isFocusable(element: HTMLElement | null): element is HTMLElement {\n  if (!element || element.closest(\"[inert]\")) return false\n  return element.matches(focusableSelector) && isVisible(element)\n}\n\nexport function getFirstFocusable(container: HTMLElement | null, includeContainer?: IncludeContainerType) {\n  const [first] = getFocusables(container, includeContainer)\n  return first || null\n}\n","import { isFocusable } from \"./focusable\"\nimport { focusableSelector, hasNegativeTabIndex, isFrame, type IncludeContainerType } from \"./shared\"\n\n/**\n * Returns the tabbable elements within the element\n */\nexport function getTabbables(container: HTMLElement | null, includeContainer?: IncludeContainerType) {\n  if (!container) return []\n  const elements = Array.from(container.querySelectorAll<HTMLElement>(focusableSelector))\n  const tabbableElements = elements.filter(isTabbable)\n\n  if (includeContainer && isTabbable(container)) {\n    tabbableElements.unshift(container)\n  }\n\n  tabbableElements.forEach((element, i) => {\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body\n      const allFrameTabbable = getTabbables(frameBody)\n      tabbableElements.splice(i, 1, ...allFrameTabbable)\n    }\n  })\n\n  if (!tabbableElements.length && includeContainer) {\n    return elements\n  }\n\n  return tabbableElements\n}\n\n/**\n * Whether this element is tabbable\n */\nexport function isTabbable(el: HTMLElement | null): el is HTMLElement {\n  if (el != null && el.tabIndex > 0) return true\n  return isFocusable(el) && !hasNegativeTabIndex(el)\n}\n\n/**\n * Returns the first focusable element within the element\n */\nexport function getFirstTabbable(container: HTMLElement | null, includeContainer?: IncludeContainerType) {\n  const [first] = getTabbables(container, includeContainer)\n  return first || null\n}\n\n/**\n * Returns the last focusable element within the element\n */\nexport function getLastTabbable(container: HTMLElement | null, includeContainer?: IncludeContainerType) {\n  const elements = getTabbables(container, includeContainer)\n  return elements[elements.length - 1] || null\n}\n\n/**\n * Returns the first and last focusable elements within the element\n */\nexport function getTabbableEdges(container: HTMLElement | null, includeContainer?: IncludeContainerType) {\n  const elements = getTabbables(container, includeContainer)\n  const first = elements[0] || null\n  const last = elements[elements.length - 1] || null\n  return [first, last]\n}\n\n/**\n * Returns the next tabbable element after the current element\n */\nexport function getNextTabbable(container: HTMLElement | null, current?: HTMLElement | null) {\n  const tabbables = getTabbables(container)\n  const doc = container?.ownerDocument || document\n  const currentElement = current ?? (doc.activeElement as HTMLElement | null)\n  if (!currentElement) return null\n  const index = tabbables.indexOf(currentElement)\n  return tabbables[index + 1] || null\n}\n"],"mappings":"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","names":[]}