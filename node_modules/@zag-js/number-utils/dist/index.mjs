// src/number.ts
function wrap(num, max) {
  return (num % max + max) % max;
}
function round(v, t) {
  let num = valueOf(v);
  const p = 10 ** (t ?? 10);
  num = Math.round(num * p) / p;
  return t ? num.toFixed(t) : v.toString();
}
function roundToDevicePixel(num) {
  if (typeof window.devicePixelRatio !== "number")
    return Math.round(num);
  const dp = window.devicePixelRatio;
  return Math.floor(num * dp + 0.5) / dp;
}
var valueToPercent = (v, r) => (valueOf(v) - r.min) * 100 / (r.max - r.min);
var percentToValue = (v, r) => r.min + (r.max - r.min) * valueOf(v);
function clamp(v, o) {
  return Math.min(Math.max(valueOf(v), o.min), o.max);
}
function countDecimals(value) {
  if (!Number.isFinite(value))
    return 0;
  let e = 1, p = 0;
  while (Math.round(value * e) / e !== value) {
    e *= 10;
    p += 1;
  }
  return p;
}
var increment = (v, s) => decimalOperation(valueOf(v), "+", s);
var decrement = (v, s) => decimalOperation(valueOf(v), "-", s);
function snapToStep(value, step) {
  const num = valueOf(value);
  const p = countDecimals(step);
  const v = Math.round(num / step) * step;
  return round(v, p);
}
function valueOf(v) {
  const res = typeof v === "number" ? v : parseFloat(v.toString().replace(/[^\w.-]+/g, ""));
  return Number.isNaN(res) ? 0 : res;
}
function formatDecimal(v, o) {
  return new Intl.NumberFormat("en-US", {
    useGrouping: false,
    style: "decimal",
    minimumFractionDigits: o.minFractionDigits,
    maximumFractionDigits: o.maxFractionDigits
  }).format(valueOf(v));
}
function isAtMax(v, o) {
  const val = valueOf(v);
  return val >= o.max;
}
function isAtMin(v, o) {
  const val = valueOf(v);
  return val <= o.min;
}
function isWithinRange(v, o) {
  const val = valueOf(v);
  return val >= o.min && val <= o.max;
}
function decimalOperation(a, op, b) {
  let result = op === "+" ? a + b : a - b;
  if (a % 1 !== 0 || b % 1 !== 0) {
    const multiplier = 10 ** Math.max(countDecimals(a), countDecimals(b));
    a = Math.round(a * multiplier);
    b = Math.round(b * multiplier);
    result = op === "+" ? a + b : a - b;
    result /= multiplier;
  }
  return result;
}

// src/rangy.ts
function rangy(o) {
  const wrap2 = (v) => rangy({ ...o, value: v });
  return {
    isInRange: isWithinRange(o.value, o),
    isAtMax: isAtMax(o.value, o),
    isAtMin: isAtMin(o.value, o),
    percent: valueToPercent(o.value, o),
    valueAsNumber: valueOf(o.value),
    value: formatDecimal(o.value, o),
    snapToStep: () => wrap2(snapToStep(o.value, o.step)),
    increment: (s) => wrap2(increment(o.value, s || o.step)),
    decrement: (s) => wrap2(decrement(o.value, s || o.step)),
    toMax: () => wrap2(o.max),
    toMin: () => wrap2(o.min),
    fromPercent: (p) => wrap2(percentToValue(p, o)),
    clamp: () => wrap2(clamp(o.value, o))
  };
}

// src/number-format.ts
var nf = new Intl.NumberFormat("en-US", { style: "decimal", maximumFractionDigits: 20 });
function formatter(n) {
  return parseFloat(nf.format(n));
}

// src/transform.ts
var transform = (a, b) => {
  const i = { min: a[0], max: a[1] };
  const o = { min: b[0], max: b[1] };
  return (v) => {
    if (i.min === i.max || o.min === o.max)
      return o.min;
    const ratio = (o.max - o.min) / (i.max - i.min);
    return o.min + ratio * (v - i.min);
  };
};
function toRanges(o) {
  const spacing = o.spacing ?? 0;
  return o.value.map((v, i) => {
    const min = i === 0 ? o.min : o.value[i - 1] + spacing;
    const max = i === o.value.length - 1 ? o.max : o.value[i + 1] - spacing;
    return { min, max, value: v };
  });
}
function toRangeArray(o) {
  let i = o.min;
  const range = [];
  while (i <= o.max) {
    range.push(i);
    i = formatter(i + o.step);
  }
  return range;
}
export {
  clamp,
  countDecimals,
  decrement,
  formatDecimal,
  increment,
  isAtMax,
  isAtMin,
  isWithinRange,
  percentToValue,
  rangy,
  round,
  roundToDevicePixel,
  snapToStep,
  toRangeArray,
  toRanges,
  transform,
  valueOf,
  valueToPercent,
  wrap
};
//# sourceMappingURL=index.mjs.map