"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  anatomy: () => anatomy,
  connect: () => connect,
  machine: () => machine
});
module.exports = __toCommonJS(src_exports);

// src/avatar.anatomy.ts
var import_anatomy = require("@zag-js/anatomy");
var anatomy = (0, import_anatomy.createAnatomy)("avatar").parts("root", "image", "fallback");
var parts = anatomy.build();

// src/avatar.dom.ts
var import_dom_query = require("@zag-js/dom-query");
var dom = (0, import_dom_query.createScope)({
  getRootId: (ctx) => `avatar:${ctx.id}`,
  getImageId: (ctx) => `avatar:${ctx.id}:image`,
  getFallbackId: (ctx) => `avatar:${ctx.id}:fallback`,
  getRootEl: (ctx) => dom.getById(ctx, dom.getRootId(ctx)),
  getImageEl: (ctx) => dom.getById(ctx, dom.getImageId(ctx))
});

// src/avatar.connect.ts
function connect(state, send, normalize) {
  const isLoaded = state.matches("loaded");
  const showFallback = !isLoaded;
  return {
    isLoaded,
    showFallback,
    setSrc(src) {
      send({ type: "SRC.SET", src });
    },
    setLoaded() {
      send({ type: "IMG.LOADED", src: "api" });
    },
    setError() {
      send({ type: "IMG.ERROR", src: "api" });
    },
    rootProps: normalize.element({
      ...parts.root.attrs,
      dir: state.context.dir,
      id: dom.getRootId(state.context),
      style: {
        display: "grid",
        gridTemplateRows: "1fr 1fr",
        overflow: "hidden"
      }
    }),
    imageProps: normalize.img({
      ...parts.image.attrs,
      dir: state.context.dir,
      id: dom.getImageId(state.context),
      "data-state": isLoaded ? "visible" : "hidden",
      onLoad() {
        send({ type: "IMG.LOADED", src: "element" });
      },
      onError() {
        send({ type: "IMG.ERROR", src: "element" });
      },
      style: {
        gridArea: "1 / 1 / 2 / 2",
        visibility: !isLoaded ? "hidden" : void 0
      }
    }),
    fallbackProps: normalize.element({
      ...parts.fallback.attrs,
      dir: state.context.dir,
      id: dom.getFallbackId(state.context),
      hidden: !showFallback,
      "data-state": isLoaded ? "hidden" : "visible",
      style: {
        gridArea: "1 / 1 / 2 / 2"
      }
    })
  };
}

// src/avatar.machine.ts
var import_core = require("@zag-js/core");
var import_mutation_observer = require("@zag-js/mutation-observer");
var import_utils = require("@zag-js/utils");
function machine(userContext) {
  const ctx = (0, import_utils.compact)(userContext);
  return (0, import_core.createMachine)(
    {
      id: "avatar",
      initial: "loading",
      activities: ["trackImageRemoval"],
      context: ctx,
      on: {
        "SRC.CHANGE": {
          target: "loading"
        },
        "IMG.UNMOUNT": {
          target: "error"
        }
      },
      states: {
        loading: {
          activities: ["trackSrcChange"],
          entry: ["checkImgStatus"],
          on: {
            "IMG.LOADED": {
              target: "loaded",
              actions: ["invokeOnLoad"]
            },
            "IMG.ERROR": {
              target: "error",
              actions: ["invokeOnError"]
            }
          }
        },
        error: {
          activities: ["trackSrcChange"],
          on: {
            "IMG.LOADED": {
              target: "loaded",
              actions: ["invokeOnLoad"]
            }
          }
        },
        loaded: {
          activities: ["trackSrcChange"],
          on: {
            "IMG.ERROR": {
              target: "error",
              actions: ["invokeOnError"]
            }
          }
        }
      }
    },
    {
      activities: {
        trackSrcChange(ctx2, _evt, { send }) {
          const img = dom.getImageEl(ctx2);
          return (0, import_mutation_observer.observeAttributes)(img, ["src", "srcset"], () => {
            send({ type: "SRC.CHANGE" });
          });
        },
        trackImageRemoval(ctx2, _evt, { send }) {
          const rootEl = dom.getRootEl(ctx2);
          return (0, import_mutation_observer.observeChildren)(rootEl, (records) => {
            const removedNodes = Array.from(records[0].removedNodes);
            const removed = removedNodes.find((node) => node.matches("[data-scope=avatar][data-part=image]"));
            if (removed) {
              send({ type: "IMG.UNMOUNT" });
            }
          });
        }
      },
      actions: {
        invokeOnLoad(ctx2) {
          ctx2.onLoadingStatusChange?.({ status: "loaded" });
        },
        invokeOnError(ctx2) {
          ctx2.onLoadingStatusChange?.({ status: "error" });
        },
        checkImgStatus(ctx2, _evt, { send }) {
          const img = dom.getImageEl(ctx2);
          if (img?.complete) {
            const type = img.currentSrc ? "IMG.LOADED" : "IMG.ERROR";
            send({ type, src: "ssr" });
          }
        }
      }
    }
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  anatomy,
  connect,
  machine
});
//# sourceMappingURL=index.js.map