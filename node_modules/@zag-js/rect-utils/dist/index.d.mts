type Point = {
    x: number;
    y: number;
};
type RectValue = {
    x: number;
    y: number;
    width: number;
    height: number;
};
type RectSide = "top" | "right" | "bottom" | "left";
type RectPoint = "top-left" | "top-center" | "top-right" | "right-center" | "left-center" | "bottom-left" | "bottom-right" | "bottom-center" | "center";
type RectEdge = [Point, Point];
type RectPoints = [Point, Point, Point, Point];
type RectEdges = Record<RectSide, RectEdge> & {
    value: RectEdge[];
};
type RectCorner = "topLeft" | "topRight" | "bottomLeft" | "bottomRight";
type RectCorners = Record<RectCorner, Point> & {
    value: RectPoints;
};
type RectCenter = "topCenter" | "rightCenter" | "leftCenter" | "bottomCenter";
type RectCenters = Record<RectCenter, Point> & {
    value: RectPoints;
};
type RectInset = Partial<Record<RectSide, number>>;
type SymmetricRectInset = {
    dx?: number;
    dy?: number;
};

declare function createRect(r: RectValue): {
    x: number;
    y: number;
    width: number;
    height: number;
    minX: number;
    minY: number;
    maxX: number;
    maxY: number;
    midX: number;
    midY: number;
    center: {
        x: number;
        y: number;
    };
};
type Rect = ReturnType<typeof createRect>;
declare function isRect(v: any): v is Rect;
declare function getRectCenters(v: Rect): {
    top: {
        x: number;
        y: number;
    };
    right: {
        x: number;
        y: number;
    };
    bottom: {
        x: number;
        y: number;
    };
    left: {
        x: number;
        y: number;
    };
};
declare function getRectCorners(v: Rect): {
    top: {
        x: number;
        y: number;
    };
    right: {
        x: number;
        y: number;
    };
    bottom: {
        x: number;
        y: number;
    };
    left: {
        x: number;
        y: number;
    };
};
declare function getRectEdges(v: Rect): {
    top: RectEdge;
    right: RectEdge;
    bottom: RectEdge;
    left: RectEdge;
};

declare function alignRect(a: Rect, ref: Rect, options: AlignOptions): Rect;
type AlignOptions = {
    h: HAlign;
    v: VAlign;
};
type HAlign = "left-inside" | "left-outside" | "center" | "right-inside" | "right-outside";
type VAlign = "top-inside" | "top-outside" | "center" | "bottom-inside" | "bottom-outside";

declare function closest(...pts: Point[]): (a: Point) => Point;
declare function closestSideToRect(ref: Rect, r: Rect): RectSide;
declare function closestSideToPoint(ref: Rect, p: Point): RectSide;

declare function containsPoint(r: Rect, p: Point): boolean;
declare function containsRect(a: Rect, b: Rect): boolean;
declare function contains(r: Rect, v: Rect | Point): boolean;

type DistanceValue = Point & {
    value: number;
};
declare function distance(a: Point, b?: Point): number;
declare function distanceFromPoint(r: Rect, p: Point): DistanceValue;
declare function distanceFromRect(a: Rect, b: Rect): DistanceValue;
declare function distanceBtwEdges(a: Rect, b: Rect): Record<RectSide, number>;

declare function getElementRect(el: HTMLElement, opts?: ElementRectOptions): Rect;
type ElementRectOptions = {
    /**
     * Whether to exclude the element's scrollbar size from the calculation.
     */
    excludeScrollbar?: boolean;
    /**
     * Whether to exclude the element's borders from the calculation.
     */
    excludeBorders?: boolean;
};

declare function getRectFromPoints(...pts: Point[]): Rect;

declare function fromRange(range: Range): Rect;

declare function toRad(d: number): number;
declare function rotate(a: Point, d: number, c: Point): Point;
declare function getRotationRect(r: Rect, deg: number): Rect;

type WindowRectOptions = {
    /**
     * Whether to exclude the element's scrollbar size from the calculation.
     */
    excludeScrollbar?: boolean;
};
/**
 * Creates a rectange from window object
 */
declare function getWindowRect(win: Window, opts?: WindowRectOptions): Rect;
/**
 * Get the rect of the window with the option to exclude the scrollbar
 */
declare function getViewportRect(win: Window, opts: WindowRectOptions): {
    x: number;
    y: number;
    width: number;
    height: number;
};

declare function getElementPolygon(rectValue: RectValue, placement: string): {
    x: number;
    y: number;
}[] | undefined;

/**
 * Checks if a Rect intersects another Rect
 */
declare function intersects(a: Rect, b: Rect): boolean;
/**
 * Returns a new Rect that represents the intersection between two Rects
 */
declare function intersection(a: Rect, b: Rect): Rect;
/**
 * Returns whether two rects collide along each edge
 */
declare function collisions(a: Rect, b: Rect): Record<RectSide, boolean>;

declare const isSymmetric: (v: any) => v is SymmetricRectInset;
declare function inset(r: Rect, i: RectInset | SymmetricRectInset): Rect;
declare function expand(r: Rect, v: number | SymmetricRectInset): Rect;
declare function shrink(r: Rect, v: number | SymmetricRectInset): Rect;
declare function shift(r: Rect, o: Partial<Point>): Rect;

declare function isPointInPolygon(polygon: Point[], point: Point): boolean;
declare function debugPolygon(polygon: Point[]): () => void;

declare function union(...rs: Rect[]): Rect;

export { type AlignOptions, type DistanceValue, type ElementRectOptions, type HAlign, type Point, type Rect, type RectCenter, type RectCenters, type RectCorner, type RectCorners, type RectEdge, type RectEdges, type RectInset, type RectPoint, type RectPoints, type RectSide, type RectValue, type SymmetricRectInset, type VAlign, type WindowRectOptions, alignRect, closest, closestSideToPoint, closestSideToRect, collisions, contains, containsPoint, containsRect, createRect, debugPolygon, distance, distanceBtwEdges, distanceFromPoint, distanceFromRect, expand, fromRange, getElementPolygon, getElementRect, getRectCenters, getRectCorners, getRectEdges, getRectFromPoints, getRotationRect, getViewportRect, getWindowRect, inset, intersection, intersects, isPointInPolygon, isRect, isSymmetric, rotate, shift, shrink, toRad, union };
