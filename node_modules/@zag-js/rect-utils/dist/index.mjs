// src/align.ts
function hAlign(a, ref, h) {
  let x = ref.minX;
  if (h === "left-inside") {
    x = ref.minX;
  }
  if (h === "left-outside") {
    x = ref.minX - ref.width;
  }
  if (h === "right-inside") {
    x = ref.maxX - ref.width;
  }
  if (h === "right-outside") {
    x = ref.maxX;
  }
  if (h === "center") {
    x = ref.midX - ref.width / 2;
  }
  return { ...a, x };
}
function vAlign(a, ref, v) {
  let y = ref.minY;
  if (v === "top-inside") {
    y = ref.minY;
  }
  if (v === "top-outside") {
    y = ref.minY - a.height;
  }
  if (v === "bottom-inside") {
    y = ref.maxY - a.height;
  }
  if (v === "bottom-outside") {
    y = ref.maxY;
  }
  if (v === "center") {
    y = ref.midY - a.height / 2;
  }
  return { ...a, y };
}
function alignRect(a, ref, options) {
  const { h, v } = options;
  return vAlign(hAlign(a, ref, h), ref, v);
}

// src/rect.ts
var point = (x, y) => ({ x, y });
function createRect(r) {
  const { x, y, width, height } = r;
  const midX = x + width / 2;
  const midY = y + height / 2;
  return {
    x,
    y,
    width,
    height,
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height,
    midX,
    midY,
    center: point(midX, midY)
  };
}
var hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
function isRect(v) {
  return hasProp(v, "x") && hasProp(v, "y") && hasProp(v, "width") && hasProp(v, "height");
}
function getRectCenters(v) {
  const top = point(v.midX, v.minY);
  const right = point(v.maxX, v.midY);
  const bottom = point(v.midX, v.maxY);
  const left = point(v.minX, v.midY);
  return { top, right, bottom, left };
}
function getRectCorners(v) {
  const top = point(v.minX, v.minY);
  const right = point(v.maxX, v.minY);
  const bottom = point(v.maxX, v.maxY);
  const left = point(v.minX, v.maxY);
  return { top, right, bottom, left };
}
function getRectEdges(v) {
  const c = getRectCorners(v);
  const top = [c.top, c.right];
  const right = [c.right, c.bottom];
  const bottom = [c.left, c.bottom];
  const left = [c.top, c.left];
  return { top, right, bottom, left };
}

// src/intersection.ts
function intersects(a, b) {
  return a.x < b.maxX && a.y < b.maxY && a.maxX > b.x && a.maxY > b.y;
}
function intersection(a, b) {
  const x = Math.max(a.x, b.x);
  const y = Math.max(a.y, b.y);
  const x2 = Math.min(a.x + a.width, b.x + b.width);
  const y2 = Math.min(a.y + a.height, b.y + b.height);
  return createRect({ x, y, width: x2 - x, height: y2 - y });
}
function collisions(a, b) {
  return {
    top: a.minY <= b.minY,
    right: a.maxX >= b.maxX,
    bottom: a.maxY >= b.maxY,
    left: a.minX <= b.minX
  };
}

// src/distance.ts
function distance(a, b = { x: 0, y: 0 }) {
  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
}
function distanceFromPoint(r, p) {
  let x = 0;
  let y = 0;
  if (p.x < r.x)
    x = r.x - p.x;
  else if (p.x > r.maxX)
    x = p.x - r.maxX;
  if (p.y < r.y)
    y = r.y - p.y;
  else if (p.y > r.maxY)
    y = p.y - r.maxY;
  return { x, y, value: distance({ x, y }) };
}
function distanceFromRect(a, b) {
  if (intersects(a, b))
    return { x: 0, y: 0, value: 0 };
  const left = a.x < b.x ? a : b;
  const right = b.x < a.x ? a : b;
  const upper = a.y < b.y ? a : b;
  const lower = b.y < a.y ? a : b;
  let x = left.x === right.x ? 0 : right.x - left.maxX;
  x = Math.max(0, x);
  let y = upper.y === lower.y ? 0 : lower.y - upper.maxY;
  y = Math.max(0, y);
  return { x, y, value: distance({ x, y }) };
}
function distanceBtwEdges(a, b) {
  return {
    left: b.x - a.x,
    top: b.y - a.y,
    right: a.maxX - b.maxX,
    bottom: a.maxY - b.maxY
  };
}

// src/closest.ts
function closest(...pts) {
  return (a) => {
    const ds = pts.map((b) => distance(b, a));
    const c = Math.min.apply(Math, ds);
    return pts[ds.indexOf(c)];
  };
}
function closestSideToRect(ref, r) {
  if (r.maxX <= ref.minX) {
    return "left";
  }
  if (r.minX >= ref.maxX) {
    return "right";
  }
  if (r.maxY <= ref.minY) {
    return "top";
  }
  if (r.minY >= ref.maxY) {
    return "bottom";
  }
  return "left";
}
function closestSideToPoint(ref, p) {
  const { x, y } = p;
  const dl = x - ref.minX;
  const dr = ref.maxX - x;
  const dt = y - ref.minY;
  const db = ref.maxY - y;
  let closest2 = dl;
  let side = "left";
  if (dr < closest2) {
    closest2 = dr;
    side = "right";
  }
  if (dt < closest2) {
    closest2 = dt;
    side = "top";
  }
  if (db < closest2) {
    side = "bottom";
  }
  return side;
}

// src/contains.ts
function containsPoint(r, p) {
  return r.minX <= p.x && p.x <= r.maxX && r.minY <= p.y && p.y <= r.maxY;
}
function containsRect(a, b) {
  return Object.values(getRectCorners(b)).every((c) => containsPoint(a, c));
}
function contains(r, v) {
  return isRect(v) ? containsRect(r, v) : containsPoint(r, v);
}

// src/from-element.ts
var styleCache = /* @__PURE__ */ new WeakMap();
function getCacheComputedStyle(el) {
  if (!styleCache.has(el)) {
    const win = el.ownerDocument.defaultView || window;
    styleCache.set(el, win.getComputedStyle(el));
  }
  return styleCache.get(el);
}
function getElementRect(el, opts = {}) {
  return createRect(getClientRect(el, opts));
}
function getClientRect(el, opts = {}) {
  const { excludeScrollbar = false, excludeBorders = false } = opts;
  const { x, y, width, height } = el.getBoundingClientRect();
  const r = { x, y, width, height };
  const style = getCacheComputedStyle(el);
  const { borderLeftWidth, borderTopWidth, borderRightWidth, borderBottomWidth } = style;
  const borderXWidth = sum(borderLeftWidth, borderRightWidth);
  const borderYWidth = sum(borderTopWidth, borderBottomWidth);
  if (excludeBorders) {
    r.width -= borderXWidth;
    r.height -= borderYWidth;
    r.x += px(borderLeftWidth);
    r.y += px(borderTopWidth);
  }
  if (excludeScrollbar) {
    const scrollbarWidth = el.offsetWidth - el.clientWidth - borderXWidth;
    const scrollbarHeight = el.offsetHeight - el.clientHeight - borderYWidth;
    r.width -= scrollbarWidth;
    r.height -= scrollbarHeight;
  }
  return r;
}
var px = (v) => parseFloat(v.replace("px", ""));
var sum = (...vals) => vals.reduce((sum2, v) => sum2 + (v ? px(v) : 0), 0);

// src/from-points.ts
function getRectFromPoints(...pts) {
  const xs = pts.map((p) => p.x);
  const ys = pts.map((p) => p.y);
  const x = Math.min(...xs);
  const y = Math.min(...ys);
  const width = Math.max(...xs) - x;
  const height = Math.max(...ys) - y;
  return createRect({ x, y, width, height });
}

// src/union.ts
var { min, max } = Math;
function union(...rs) {
  const pMin = {
    x: min.apply(
      Math,
      rs.map((r) => r.minX)
    ),
    y: min.apply(
      Math,
      rs.map((r) => r.minY)
    )
  };
  const pMax = {
    x: max.apply(
      Math,
      rs.map((r) => r.maxX)
    ),
    y: max.apply(
      Math,
      rs.map((r) => r.maxY)
    )
  };
  return getRectFromPoints(pMin, pMax);
}

// src/from-range.ts
function fromRange(range) {
  let rs = [];
  const rects = Array.from(range.getClientRects());
  if (rects.length) {
    rs = rs.concat(rects.map(createRect));
    return union.apply(void 0, rs);
  }
  let start = range.startContainer;
  if (start.nodeType === Node.TEXT_NODE) {
    start = start.parentNode;
  }
  if (start instanceof HTMLElement) {
    const r = getElementRect(start);
    rs.push({ ...r, x: r.maxX, width: 0 });
  }
  return union.apply(void 0, rs);
}

// src/from-rotation.ts
function toRad(d) {
  return d % 360 * Math.PI / 180;
}
function rotate(a, d, c) {
  const r = toRad(d);
  const sin = Math.sin(r);
  const cos = Math.cos(r);
  const x = a.x - c.x;
  const y = a.y - c.y;
  return {
    x: c.x + x * cos - y * sin,
    y: c.y + x * sin + y * cos
  };
}
function getRotationRect(r, deg) {
  const rr = Object.values(getRectCorners(r)).map((p) => rotate(p, deg, r.center));
  const xs = rr.map((p) => p.x);
  const ys = rr.map((p) => p.y);
  const minX = Math.min(...xs);
  const minY = Math.min(...ys);
  const maxX = Math.max(...xs);
  const maxY = Math.max(...ys);
  return createRect({
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  });
}

// src/from-window.ts
function getWindowRect(win, opts = {}) {
  return createRect(getViewportRect(win, opts));
}
function getViewportRect(win, opts) {
  const { excludeScrollbar = false } = opts;
  const { innerWidth, innerHeight, document: doc, visualViewport } = win;
  const width = visualViewport?.width || innerWidth;
  const height = visualViewport?.height || innerHeight;
  const rect = { x: 0, y: 0, width, height };
  if (excludeScrollbar) {
    const scrollbarWidth = innerWidth - doc.documentElement.clientWidth;
    const scrollbarHeight = innerHeight - doc.documentElement.clientHeight;
    rect.width -= scrollbarWidth;
    rect.height -= scrollbarHeight;
  }
  return rect;
}

// src/get-polygon.ts
function getElementPolygon(rectValue, placement) {
  const rect = createRect(rectValue);
  const { top, right, left, bottom } = getRectCorners(rect);
  const [base] = placement.split("-");
  return {
    top: [left, top, right, bottom],
    right: [top, right, bottom, left],
    bottom: [top, left, bottom, right],
    left: [right, top, left, bottom]
  }[base];
}

// src/operations.ts
var isSymmetric = (v) => "dx" in v || "dy" in v;
function inset(r, i) {
  const v = isSymmetric(i) ? { left: i.dx, right: i.dx, top: i.dy, bottom: i.dy } : i;
  const { top = 0, right = 0, bottom = 0, left = 0 } = v;
  return createRect({
    x: r.x + left,
    y: r.y + top,
    width: r.width - left - right,
    height: r.height - top - bottom
  });
}
function expand(r, v) {
  const value = typeof v === "number" ? { dx: -v, dy: -v } : v;
  return inset(r, value);
}
function shrink(r, v) {
  const value = typeof v === "number" ? { dx: -v, dy: -v } : v;
  return inset(r, value);
}
function shift(r, o) {
  const { x = 0, y = 0 } = o;
  return createRect({
    x: r.x + x,
    y: r.y + y,
    width: r.width,
    height: r.height
  });
}

// src/polygon.ts
function isPointInPolygon(polygon, point2) {
  const { x, y } = point2;
  let c = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {
      c = !c;
    }
  }
  return c;
}
function createPolygonElement() {
  const id = "debug-polygon";
  const existingPolygon = document.getElementById(id);
  if (existingPolygon) {
    return existingPolygon;
  }
  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  Object.assign(svg.style, {
    top: "0",
    left: "0",
    width: "100%",
    height: "100%",
    opacity: "0.15",
    position: "fixed",
    pointerEvents: "none",
    fill: "red"
  });
  const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
  polygon.setAttribute("id", id);
  polygon.setAttribute("points", "0,0 0,0");
  svg.appendChild(polygon);
  document.body.appendChild(svg);
  return polygon;
}
function debugPolygon(polygon) {
  const el = createPolygonElement();
  const points = polygon.map((point2) => `${point2.x},${point2.y}`).join(" ");
  el.setAttribute("points", points);
  return () => {
    el.remove();
  };
}
export {
  alignRect,
  closest,
  closestSideToPoint,
  closestSideToRect,
  collisions,
  contains,
  containsPoint,
  containsRect,
  createRect,
  debugPolygon,
  distance,
  distanceBtwEdges,
  distanceFromPoint,
  distanceFromRect,
  expand,
  fromRange,
  getElementPolygon,
  getElementRect,
  getRectCenters,
  getRectCorners,
  getRectEdges,
  getRectFromPoints,
  getRotationRect,
  getViewportRect,
  getWindowRect,
  inset,
  intersection,
  intersects,
  isPointInPolygon,
  isRect,
  isSymmetric,
  rotate,
  shift,
  shrink,
  toRad,
  union
};
//# sourceMappingURL=index.mjs.map