"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  anatomy: () => anatomy,
  collection: () => collection,
  connect: () => connect,
  machine: () => machine
});
module.exports = __toCommonJS(src_exports);

// src/combobox.anatomy.ts
var import_anatomy = require("@zag-js/anatomy");
var anatomy = (0, import_anatomy.createAnatomy)("combobox").parts(
  "root",
  "label",
  "input",
  "positioner",
  "control",
  "trigger",
  "content",
  "clearTrigger",
  "item",
  "itemText",
  "itemIndicator",
  "itemGroup",
  "itemGroupLabel"
);
var parts = anatomy.build();

// src/combobox.collection.ts
var import_collection = require("@zag-js/collection");
var import_core = require("@zag-js/core");
var collection = (options) => {
  return (0, import_core.ref)(new import_collection.Collection(options));
};
collection.empty = () => {
  return (0, import_core.ref)(new import_collection.Collection({ items: [] }));
};

// src/combobox.connect.ts
var import_dom_event = require("@zag-js/dom-event");
var import_dom_query2 = require("@zag-js/dom-query");
var import_popper = require("@zag-js/popper");

// src/combobox.dom.ts
var import_dom_query = require("@zag-js/dom-query");
var dom = (0, import_dom_query.createScope)({
  getRootId: (ctx) => ctx.ids?.root ?? `combobox:${ctx.id}`,
  getLabelId: (ctx) => ctx.ids?.label ?? `combobox:${ctx.id}:label`,
  getControlId: (ctx) => ctx.ids?.control ?? `combobox:${ctx.id}:control`,
  getInputId: (ctx) => ctx.ids?.input ?? `combobox:${ctx.id}:input`,
  getContentId: (ctx) => ctx.ids?.content ?? `combobox:${ctx.id}:content`,
  getPositionerId: (ctx) => ctx.ids?.positioner ?? `combobox:${ctx.id}:popper`,
  getTriggerId: (ctx) => ctx.ids?.trigger ?? `combobox:${ctx.id}:toggle-btn`,
  getClearTriggerId: (ctx) => ctx.ids?.clearTrigger ?? `combobox:${ctx.id}:clear-btn`,
  getItemGroupId: (ctx, id) => ctx.ids?.itemGroup?.(id) ?? `combobox:${ctx.id}:optgroup:${id}`,
  getItemGroupLabelId: (ctx, id) => ctx.ids?.itemGroupLabel?.(id) ?? `combobox:${ctx.id}:optgroup-label:${id}`,
  getItemId: (ctx, id) => `combobox:${ctx.id}:option:${id}`,
  getContentEl: (ctx) => dom.getById(ctx, dom.getContentId(ctx)),
  getInputEl: (ctx) => dom.getById(ctx, dom.getInputId(ctx)),
  getPositionerEl: (ctx) => dom.getById(ctx, dom.getPositionerId(ctx)),
  getControlEl: (ctx) => dom.getById(ctx, dom.getControlId(ctx)),
  getTriggerEl: (ctx) => dom.getById(ctx, dom.getTriggerId(ctx)),
  getClearTriggerEl: (ctx) => dom.getById(ctx, dom.getClearTriggerId(ctx)),
  isInputFocused: (ctx) => dom.getDoc(ctx).activeElement === dom.getInputEl(ctx),
  getHighlightedItemEl: (ctx) => {
    const value = ctx.highlightedValue;
    if (value == null)
      return;
    return dom.getContentEl(ctx)?.querySelector(`[role=option][data-value="${CSS.escape(value)}"`);
  }
});

// src/combobox.connect.ts
function connect(state, send, normalize) {
  const translations = state.context.translations;
  const collection2 = state.context.collection;
  const isDisabled = state.context.disabled;
  const isInteractive = state.context.isInteractive;
  const isInvalid = state.context.invalid;
  const isReadOnly = state.context.readOnly;
  const isOpen = state.hasTag("open");
  const isFocused = state.hasTag("focused");
  const popperStyles = (0, import_popper.getPlacementStyles)({
    ...state.context.positioning,
    placement: state.context.currentPlacement
  });
  function getItemState(props) {
    const { item } = props;
    const disabled = collection2.isItemDisabled(item);
    const value = collection2.itemToValue(item);
    return {
      value,
      isDisabled: Boolean(disabled || isDisabled),
      isHighlighted: state.context.highlightedValue === value,
      isSelected: state.context.value.includes(value)
    };
  }
  return {
    isFocused,
    isOpen,
    inputValue: state.context.inputValue,
    isInputValueEmpty: state.context.isInputValueEmpty,
    highlightedValue: state.context.highlightedValue,
    highlightedItem: state.context.highlightedItem,
    value: state.context.value,
    valueAsString: state.context.valueAsString,
    hasSelectedItems: state.context.hasSelectedItems,
    selectedItems: state.context.selectedItems,
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    setCollection(collection3) {
      send({ type: "COLLECTION.SET", value: collection3 });
    },
    highlightValue(value) {
      send({ type: "HIGHLIGHTED_VALUE.SET", value });
    },
    selectValue(value) {
      send({ type: "ITEM.SELECT", value });
    },
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    setInputValue(value) {
      send({ type: "INPUT_VALUE.SET", value });
    },
    clearValue(value) {
      if (value != null) {
        send({ type: "ITEM.CLEAR", value });
      } else {
        send("VALUE.CLEAR");
      }
    },
    focus() {
      dom.getInputEl(state.context)?.focus();
    },
    open() {
      send("OPEN");
    },
    close() {
      send("CLOSE");
    },
    rootProps: normalize.element({
      ...parts.root.attrs,
      dir: state.context.dir,
      id: dom.getRootId(state.context),
      "data-invalid": (0, import_dom_query2.dataAttr)(isInvalid),
      "data-readonly": (0, import_dom_query2.dataAttr)(isReadOnly)
    }),
    labelProps: normalize.label({
      ...parts.label.attrs,
      dir: state.context.dir,
      htmlFor: dom.getInputId(state.context),
      id: dom.getLabelId(state.context),
      "data-readonly": (0, import_dom_query2.dataAttr)(isReadOnly),
      "data-disabled": (0, import_dom_query2.dataAttr)(isDisabled),
      "data-invalid": (0, import_dom_query2.dataAttr)(isInvalid),
      "data-focus": (0, import_dom_query2.dataAttr)(isFocused)
    }),
    controlProps: normalize.element({
      ...parts.control.attrs,
      dir: state.context.dir,
      id: dom.getControlId(state.context),
      "data-state": isOpen ? "open" : "closed",
      "data-focus": (0, import_dom_query2.dataAttr)(isFocused),
      "data-disabled": (0, import_dom_query2.dataAttr)(isDisabled),
      "data-invalid": (0, import_dom_query2.dataAttr)(isInvalid)
    }),
    positionerProps: normalize.element({
      ...parts.positioner.attrs,
      dir: state.context.dir,
      id: dom.getPositionerId(state.context),
      style: popperStyles.floating
    }),
    inputProps: normalize.input({
      ...parts.input.attrs,
      dir: state.context.dir,
      "aria-invalid": (0, import_dom_query2.ariaAttr)(isInvalid),
      "data-invalid": (0, import_dom_query2.dataAttr)(isInvalid),
      name: state.context.name,
      form: state.context.form,
      disabled: isDisabled,
      autoFocus: state.context.autoFocus,
      autoComplete: "off",
      autoCorrect: "off",
      autoCapitalize: "none",
      spellCheck: "false",
      readOnly: isReadOnly,
      placeholder: state.context.placeholder,
      id: dom.getInputId(state.context),
      type: "text",
      role: "combobox",
      defaultValue: state.context.inputValue || state.context.valueAsString,
      "aria-autocomplete": state.context.autoComplete ? "both" : "list",
      "aria-controls": isOpen ? dom.getContentId(state.context) : void 0,
      "aria-expanded": isOpen,
      "data-state": isOpen ? "open" : "closed",
      "aria-activedescendant": state.context.highlightedValue ? dom.getItemId(state.context, state.context.highlightedValue) : void 0,
      onCompositionStart() {
        send("INPUT.COMPOSITION_START");
      },
      onCompositionEnd() {
        (0, import_dom_query2.raf)(() => {
          send("INPUT.COMPOSITION_END");
        });
      },
      onClick() {
        if (!isInteractive)
          return;
        send("INPUT.CLICK");
      },
      onFocus() {
        if (isDisabled)
          return;
        send("INPUT.FOCUS");
      },
      onBlur() {
        if (isDisabled)
          return;
        send("INPUT.BLUR");
      },
      onChange(event) {
        send({ type: "INPUT.CHANGE", value: event.currentTarget.value });
      },
      onKeyDown(event) {
        if (!isInteractive)
          return;
        const evt = (0, import_dom_event.getNativeEvent)(event);
        if (evt.ctrlKey || evt.shiftKey || evt.isComposing)
          return;
        const keymap = {
          ArrowDown(event2) {
            send({ type: event2.altKey ? "INPUT.ARROW_DOWN+ALT" : "INPUT.ARROW_DOWN" });
            event2.preventDefault();
            event2.stopPropagation();
          },
          ArrowUp() {
            send(event.altKey ? "INPUT.ARROW_UP+ALT" : "INPUT.ARROW_UP");
            event.preventDefault();
            event.stopPropagation();
          },
          Home(event2) {
            const isModified = event2.ctrlKey || event2.metaKey || event2.shiftKey;
            if (isModified)
              return;
            send("INPUT.HOME");
            if (isOpen) {
              event2.preventDefault();
              event2.stopPropagation();
            }
          },
          End(event2) {
            const isModified = event2.ctrlKey || event2.metaKey || event2.shiftKey;
            if (isModified)
              return;
            send("INPUT.END");
            if (isOpen) {
              event2.preventDefault();
              event2.stopPropagation();
            }
          },
          Enter() {
            if (state.context.composing)
              return;
            send("INPUT.ENTER");
            event.preventDefault();
            event.stopPropagation();
          },
          Escape() {
            send("INPUT.ESCAPE");
            event.preventDefault();
          }
        };
        const key = (0, import_dom_event.getEventKey)(event, state.context);
        const exec = keymap[key];
        exec?.(event);
      }
    }),
    triggerProps: normalize.button({
      ...parts.trigger.attrs,
      dir: state.context.dir,
      id: dom.getTriggerId(state.context),
      "aria-haspopup": "listbox",
      type: "button",
      tabIndex: -1,
      "aria-label": translations.triggerLabel,
      "aria-expanded": isOpen,
      "data-state": isOpen ? "open" : "closed",
      "aria-controls": isOpen ? dom.getContentId(state.context) : void 0,
      disabled: isDisabled,
      "data-readonly": (0, import_dom_query2.dataAttr)(isReadOnly),
      "data-disabled": (0, import_dom_query2.dataAttr)(isDisabled),
      onPointerDown(event) {
        const evt = (0, import_dom_event.getNativeEvent)(event);
        if (!isInteractive || !(0, import_dom_event.isLeftClick)(evt) || evt.pointerType === "touch")
          return;
        send("TRIGGER.CLICK");
        event.preventDefault();
      },
      onPointerUp(event) {
        if (event.pointerType !== "touch")
          return;
        send("TRIGGER.CLICK");
      },
      style: { outline: 0 }
    }),
    contentProps: normalize.element({
      ...parts.content.attrs,
      dir: state.context.dir,
      id: dom.getContentId(state.context),
      role: "listbox",
      tabIndex: -1,
      hidden: !isOpen,
      "data-state": isOpen ? "open" : "closed",
      "aria-labelledby": dom.getLabelId(state.context),
      "aria-multiselectable": state.context.multiple ? true : void 0,
      onPointerDown(event) {
        event.preventDefault();
      }
    }),
    clearTriggerProps: normalize.button({
      ...parts.clearTrigger.attrs,
      dir: state.context.dir,
      id: dom.getClearTriggerId(state.context),
      type: "button",
      tabIndex: -1,
      disabled: isDisabled,
      "aria-label": translations.clearTriggerLabel,
      hidden: state.context.isInputValueEmpty,
      onPointerDown(event) {
        const evt = (0, import_dom_event.getNativeEvent)(event);
        if (!isInteractive || !(0, import_dom_event.isLeftClick)(evt))
          return;
        send({ type: "VALUE.CLEAR", src: "clear-trigger" });
        event.preventDefault();
      }
    }),
    getItemState,
    getItemProps(props) {
      const itemState = getItemState(props);
      const value = itemState.value;
      return normalize.element({
        ...parts.item.attrs,
        dir: state.context.dir,
        id: dom.getItemId(state.context, value),
        role: "option",
        tabIndex: -1,
        "data-highlighted": (0, import_dom_query2.dataAttr)(itemState.isHighlighted),
        "data-state": itemState.isSelected ? "checked" : "unchecked",
        "aria-selected": itemState.isHighlighted,
        "aria-disabled": itemState.isDisabled,
        "data-disabled": (0, import_dom_query2.dataAttr)(itemState.isDisabled),
        "data-value": itemState.value,
        onPointerMove() {
          if (itemState.isDisabled)
            return;
          send({ type: "ITEM.POINTER_OVER", value });
        },
        onPointerLeave() {
          if (itemState.isDisabled)
            return;
          send({ type: "ITEM.POINTER_LEAVE", value });
        },
        onPointerUp(event) {
          if (itemState.isDisabled || (0, import_dom_event.isContextMenuEvent)(event))
            return;
          send({ type: "ITEM.CLICK", src: "pointerup", value });
        }
      });
    },
    getItemTextProps(props) {
      const itemState = getItemState(props);
      return normalize.element({
        ...parts.itemText.attrs,
        dir: state.context.dir,
        "data-disabled": (0, import_dom_query2.dataAttr)(itemState.isDisabled),
        "data-highlighted": (0, import_dom_query2.dataAttr)(itemState.isHighlighted)
      });
    },
    getItemIndicatorProps(props) {
      const itemState = getItemState(props);
      return normalize.element({
        "aria-hidden": true,
        ...parts.itemIndicator.attrs,
        dir: state.context.dir,
        "data-state": itemState.isSelected ? "checked" : "unchecked",
        hidden: !itemState.isSelected
      });
    },
    getItemGroupProps(props) {
      const { id } = props;
      return normalize.element({
        ...parts.itemGroup.attrs,
        dir: state.context.dir,
        id: dom.getItemGroupId(state.context, id),
        "aria-labelledby": dom.getItemGroupLabelId(state.context, id)
      });
    },
    getItemGroupLabelProps(props) {
      const { htmlFor } = props;
      return normalize.element({
        ...parts.itemGroupLabel.attrs,
        dir: state.context.dir,
        id: dom.getItemGroupLabelId(state.context, htmlFor),
        role: "group"
      });
    }
  };
}

// src/combobox.machine.ts
var import_aria_hidden = require("@zag-js/aria-hidden");
var import_core2 = require("@zag-js/core");
var import_dismissable = require("@zag-js/dismissable");
var import_dom_query3 = require("@zag-js/dom-query");
var import_mutation_observer = require("@zag-js/mutation-observer");
var import_popper2 = require("@zag-js/popper");
var import_utils = require("@zag-js/utils");
var { and, not } = import_core2.guards;
var KEYDOWN_EVENT_REGEX = /(ARROW_UP|ARROW_DOWN|HOME|END|ENTER|ESCAPE)/;
function machine(userContext) {
  const ctx = (0, import_utils.compact)(userContext);
  return (0, import_core2.createMachine)(
    {
      id: "combobox",
      initial: ctx.autoFocus ? "focused" : "idle",
      context: {
        loop: true,
        openOnClick: false,
        composing: false,
        value: [],
        highlightedValue: null,
        inputValue: "",
        selectOnBlur: true,
        allowCustomValue: false,
        closeOnSelect: true,
        inputBehavior: "none",
        selectionBehavior: "replace",
        ...ctx,
        collection: ctx.collection ?? collection.empty(),
        positioning: {
          placement: "bottom",
          flip: false,
          sameWidth: true,
          ...ctx.positioning
        },
        translations: {
          triggerLabel: "Toggle suggestions",
          clearTriggerLabel: "Clear value",
          ...ctx.translations
        }
      },
      computed: {
        isInputValueEmpty: (ctx2) => ctx2.inputValue.length === 0,
        isInteractive: (ctx2) => !(ctx2.readOnly || ctx2.disabled),
        autoComplete: (ctx2) => ctx2.inputBehavior === "autocomplete",
        autoHighlight: (ctx2) => ctx2.inputBehavior === "autohighlight",
        selectedItems: (ctx2) => ctx2.collection.items(ctx2.value),
        highlightedItem: (ctx2) => ctx2.collection.item(ctx2.highlightedValue),
        valueAsString: (ctx2) => ctx2.collection.itemsToString(ctx2.selectedItems),
        hasSelectedItems: (ctx2) => ctx2.value.length > 0
      },
      watch: {
        inputValue: ["syncInputValue"],
        highlightedValue: ["autofillInputValue"]
      },
      on: {
        "HIGHLIGHTED_VALUE.SET": {
          actions: ["setHighlightedItem"]
        },
        "ITEM.SELECT": {
          actions: ["selectItem"]
        },
        "ITEM.CLEAR": {
          actions: ["clearItem"]
        },
        "VALUE.SET": {
          actions: ["setSelectedItems"]
        },
        "INPUT_VALUE.SET": {
          actions: "setInputValue"
        },
        "VALUE.CLEAR": {
          target: "focused",
          actions: ["clearInputValue", "clearSelectedItems"]
        },
        "INPUT.COMPOSITION_START": {
          actions: ["setIsComposing"]
        },
        "INPUT.COMPOSITION_END": {
          actions: ["clearIsComposing"]
        },
        "COLLECTION.SET": {
          actions: ["setCollection"]
        },
        "POSITIONING.SET": {
          actions: ["reposition"]
        }
      },
      states: {
        idle: {
          tags: ["idle", "closed"],
          entry: ["scrollContentToTop", "clearHighlightedItem"],
          on: {
            "TRIGGER.CLICK": {
              target: "interacting",
              actions: ["focusInput", "highlightFirstSelectedItem", "invokeOnOpen"]
            },
            "INPUT.CLICK": {
              guard: "openOnClick",
              target: "interacting",
              actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
            },
            "INPUT.FOCUS": {
              target: "focused"
            },
            OPEN: {
              target: "interacting",
              actions: ["invokeOnOpen"]
            }
          }
        },
        focused: {
          tags: ["focused", "closed"],
          entry: ["focusInput", "scrollContentToTop", "clearHighlightedItem"],
          on: {
            "INPUT.CHANGE": {
              target: "suggesting",
              actions: "setInputValue"
            },
            "LAYER.INTERACT_OUTSIDE": {
              target: "idle"
            },
            "INPUT.ESCAPE": {
              guard: and("isCustomValue", not("allowCustomValue")),
              actions: "revertInputValue"
            },
            "INPUT.BLUR": {
              target: "idle"
            },
            "INPUT.CLICK": {
              guard: "openOnClick",
              target: "interacting",
              actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
            },
            "TRIGGER.CLICK": {
              target: "interacting",
              actions: ["focusInput", "highlightFirstSelectedItem", "invokeOnOpen"]
            },
            "INPUT.ARROW_DOWN": [
              {
                guard: "autoComplete",
                target: "interacting",
                actions: ["invokeOnOpen"]
              },
              {
                guard: "hasSelectedItems",
                target: "interacting",
                actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
              },
              {
                target: "interacting",
                actions: ["highlightFirstItem", "invokeOnOpen"]
              }
            ],
            "INPUT.ARROW_DOWN+ALT": {
              target: "interacting",
              actions: "invokeOnOpen"
            },
            "INPUT.ARROW_UP": [
              {
                guard: "autoComplete",
                target: "interacting",
                actions: "invokeOnOpen"
              },
              {
                guard: "hasSelectedItems",
                target: "interacting",
                actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
              },
              {
                target: "interacting",
                actions: ["highlightLastItem", "invokeOnOpen"]
              }
            ],
            OPEN: {
              target: "interacting",
              actions: ["invokeOnOpen"]
            }
          }
        },
        interacting: {
          tags: ["open", "focused"],
          activities: ["scrollIntoView", "trackDismissableLayer", "computePlacement", "hideOtherElements"],
          on: {
            "INPUT.HOME": {
              actions: ["highlightFirstItem"]
            },
            "INPUT.END": {
              actions: ["highlightLastItem"]
            },
            "INPUT.ARROW_DOWN": [
              {
                guard: and("autoComplete", "isLastItemHighlighted"),
                actions: ["clearHighlightedItem", "scrollContentToTop"]
              },
              {
                actions: ["highlightNextItem"]
              }
            ],
            "INPUT.ARROW_UP": [
              {
                guard: and("autoComplete", "isFirstItemHighlighted"),
                actions: "clearHighlightedItem"
              },
              {
                actions: "highlightPrevItem"
              }
            ],
            "INPUT.ARROW_UP+ALT": {
              target: "focused"
            },
            "INPUT.ENTER": [
              {
                guard: not("closeOnSelect"),
                actions: ["selectHighlightedItem"]
              },
              {
                target: "focused",
                actions: ["selectHighlightedItem", "invokeOnClose"]
              }
            ],
            "INPUT.CHANGE": [
              {
                guard: "autoComplete",
                target: "suggesting",
                actions: ["setInputValue"]
              },
              {
                target: "suggesting",
                actions: ["clearHighlightedItem", "setInputValue"]
              }
            ],
            "ITEM.POINTER_OVER": {
              actions: ["setHighlightedItem"]
            },
            "ITEM.POINTER_LEAVE": {
              actions: ["clearHighlightedItem"]
            },
            "ITEM.CLICK": [
              {
                guard: not("closeOnSelect"),
                actions: ["selectItem"]
              },
              {
                target: "focused",
                actions: ["selectItem", "invokeOnClose"]
              }
            ],
            "LAYER.ESCAPE": [
              {
                guard: "autoComplete",
                target: "focused",
                actions: ["syncInputValue", "invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose"]
              }
            ],
            "TRIGGER.CLICK": {
              target: "focused",
              actions: "invokeOnClose"
            },
            "LAYER.INTERACT_OUTSIDE": [
              {
                guard: and("selectOnBlur", "hasHighlightedItem"),
                target: "idle",
                actions: ["selectHighlightedItem", "invokeOnClose"]
              },
              {
                guard: and("isCustomValue", not("allowCustomValue")),
                target: "idle",
                actions: ["revertInputValue", "invokeOnClose"]
              },
              {
                target: "idle",
                actions: "invokeOnClose"
              }
            ],
            CLOSE: {
              target: "focused",
              actions: "invokeOnClose"
            }
          }
        },
        suggesting: {
          tags: ["open", "focused"],
          activities: [
            "trackDismissableLayer",
            "scrollIntoView",
            "computePlacement",
            "trackChildNodes",
            "hideOtherElements"
          ],
          entry: ["focusInput", "invokeOnOpen"],
          on: {
            CHILDREN_CHANGE: {
              guard: not("isHighlightedItemVisible"),
              actions: ["highlightFirstItem"]
            },
            "INPUT.ARROW_DOWN": {
              target: "interacting",
              actions: "highlightNextItem"
            },
            "INPUT.ARROW_UP": {
              target: "interacting",
              actions: "highlightPrevItem"
            },
            "INPUT.ARROW_UP+ALT": {
              target: "focused"
            },
            "INPUT.HOME": {
              target: "interacting",
              actions: ["highlightFirstItem"]
            },
            "INPUT.END": {
              target: "interacting",
              actions: ["highlightLastItem"]
            },
            "INPUT.ENTER": [
              {
                guard: not("closeOnSelect"),
                actions: ["selectHighlightedItem"]
              },
              {
                target: "focused",
                actions: ["selectHighlightedItem", "invokeOnClose"]
              }
            ],
            "INPUT.CHANGE": [
              {
                guard: "autoHighlight",
                actions: ["setInputValue", "highlightFirstItem"]
              },
              {
                actions: ["clearHighlightedItem", "setInputValue"]
              }
            ],
            "LAYER.ESCAPE": {
              target: "focused",
              actions: "invokeOnClose"
            },
            "ITEM.POINTER_OVER": {
              target: "interacting",
              actions: "setHighlightedItem"
            },
            "ITEM.POINTER_LEAVE": {
              actions: "clearHighlightedItem"
            },
            "LAYER.INTERACT_OUTSIDE": [
              {
                guard: and("isCustomValue", not("allowCustomValue")),
                target: "idle",
                actions: ["revertInputValue", "invokeOnClose"]
              },
              {
                target: "idle",
                actions: "invokeOnClose"
              }
            ],
            "TRIGGER.CLICK": {
              target: "focused",
              actions: "invokeOnClose"
            },
            "ITEM.CLICK": [
              {
                guard: not("closeOnSelect"),
                actions: ["selectItem"]
              },
              {
                target: "focused",
                actions: ["selectItem", "invokeOnClose"]
              }
            ],
            CLOSE: {
              target: "focused",
              actions: "invokeOnClose"
            }
          }
        }
      }
    },
    {
      guards: {
        openOnClick: (ctx2) => !!ctx2.openOnClick,
        isInputValueEmpty: (ctx2) => ctx2.isInputValueEmpty,
        autoComplete: (ctx2) => ctx2.autoComplete && !ctx2.multiple,
        autoHighlight: (ctx2) => ctx2.autoHighlight,
        isFirstItemHighlighted: (ctx2) => ctx2.collection.first() === ctx2.highlightedValue,
        isLastItemHighlighted: (ctx2) => ctx2.collection.last() === ctx2.highlightedValue,
        isCustomValue: (ctx2) => ctx2.inputValue !== ctx2.valueAsString,
        allowCustomValue: (ctx2) => !!ctx2.allowCustomValue,
        hasHighlightedItem: (ctx2) => ctx2.highlightedValue != null,
        hasSelectedItems: (ctx2) => ctx2.hasSelectedItems,
        selectOnBlur: (ctx2) => !!ctx2.selectOnBlur,
        closeOnSelect: (ctx2) => ctx2.multiple ? false : !!ctx2.closeOnSelect,
        isHighlightedItemVisible: (ctx2) => ctx2.collection.has(ctx2.highlightedValue)
      },
      activities: {
        trackDismissableLayer(ctx2, _evt, { send }) {
          const contentEl = () => dom.getContentEl(ctx2);
          return (0, import_dismissable.trackDismissableElement)(contentEl, {
            defer: true,
            exclude: () => [
              dom.getInputEl(ctx2),
              dom.getContentEl(ctx2),
              dom.getTriggerEl(ctx2),
              dom.getClearTriggerEl(ctx2)
            ],
            onFocusOutside: ctx2.onFocusOutside,
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onInteractOutside: ctx2.onInteractOutside,
            onEscapeKeyDown(event) {
              event.preventDefault();
              send("LAYER.ESCAPE");
            },
            onDismiss() {
              send({ type: "LAYER.INTERACT_OUTSIDE" });
            }
          });
        },
        hideOtherElements(ctx2) {
          return (0, import_aria_hidden.ariaHidden)([dom.getInputEl(ctx2), dom.getContentEl(ctx2), dom.getTriggerEl(ctx2)]);
        },
        computePlacement(ctx2) {
          const controlEl = () => dom.getControlEl(ctx2);
          const positionerEl = () => dom.getPositionerEl(ctx2);
          ctx2.currentPlacement = ctx2.positioning.placement;
          return (0, import_popper2.getPlacement)(controlEl, positionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            },
            onCleanup() {
              ctx2.currentPlacement = void 0;
            }
          });
        },
        // in event the options are fetched (async), we still want to auto-highlight the first option
        trackChildNodes(ctx2, _evt, { send }) {
          if (!ctx2.autoHighlight)
            return;
          const exec = () => send("CHILDREN_CHANGE");
          exec();
          return (0, import_mutation_observer.observeChildren)(dom.getContentEl(ctx2), exec);
        },
        scrollIntoView(ctx2, _evt, { getState }) {
          const inputEl = dom.getInputEl(ctx2);
          const exec = () => {
            const state = getState();
            const isPointer = state.event.type.startsWith("ITEM.POINTER");
            if (isPointer || !ctx2.highlightedValue)
              return;
            const optionEl = dom.getHighlightedItemEl(ctx2);
            optionEl?.scrollIntoView({ block: "nearest" });
          };
          (0, import_dom_query3.raf)(() => exec());
          return (0, import_mutation_observer.observeAttributes)(inputEl, ["aria-activedescendant"], exec);
        }
      },
      actions: {
        reposition(ctx2, evt) {
          const controlEl = () => dom.getControlEl(ctx2);
          const positionerEl = () => dom.getPositionerEl(ctx2);
          (0, import_popper2.getPlacement)(controlEl, positionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        setIsComposing(ctx2) {
          ctx2.composing = true;
        },
        clearIsComposing(ctx2) {
          ctx2.composing = false;
        },
        setHighlightedItem(ctx2, evt) {
          set.highlightedItem(ctx2, evt.value);
        },
        clearHighlightedItem(ctx2) {
          set.highlightedItem(ctx2, null, true);
        },
        selectHighlightedItem(ctx2) {
          set.selectedItem(ctx2, ctx2.highlightedValue);
        },
        selectItem(ctx2, evt) {
          set.selectedItem(ctx2, evt.value);
        },
        clearItem(ctx2, evt) {
          const value = ctx2.value.filter((v) => v !== evt.value);
          set.selectedItems(ctx2, value);
        },
        focusInput(ctx2) {
          if (dom.isInputFocused(ctx2))
            return;
          dom.getInputEl(ctx2)?.focus({ preventScroll: true });
        },
        syncInputValue(ctx2, evt) {
          const isTyping = !KEYDOWN_EVENT_REGEX.test(evt.type);
          const inputEl = dom.getInputEl(ctx2);
          if (!inputEl)
            return;
          inputEl.value = ctx2.inputValue;
          (0, import_dom_query3.raf)(() => {
            if (isTyping)
              return;
            const { selectionStart, selectionEnd } = inputEl;
            if (Math.abs((selectionEnd ?? 0) - (selectionStart ?? 0)) !== 0)
              return;
            if (selectionStart !== 0)
              return;
            inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);
          });
        },
        setInputValue(ctx2, evt) {
          set.inputValue(ctx2, evt.value);
        },
        clearInputValue(ctx2) {
          set.inputValue(ctx2, "");
        },
        revertInputValue(ctx2) {
          set.inputValue(ctx2, ctx2.hasSelectedItems ? ctx2.valueAsString : "");
        },
        setSelectedItems(ctx2, evt) {
          set.selectedItems(ctx2, evt.value);
        },
        clearSelectedItems(ctx2) {
          set.selectedItems(ctx2, []);
        },
        scrollContentToTop(ctx2) {
          const contentEl = dom.getContentEl(ctx2);
          if (!contentEl)
            return;
          contentEl.scrollTop = 0;
        },
        invokeOnOpen(ctx2) {
          ctx2.onOpenChange?.({ open: true });
        },
        invokeOnClose(ctx2) {
          ctx2.onOpenChange?.({ open: false });
        },
        highlightFirstItem(ctx2) {
          const value = ctx2.collection.first();
          set.highlightedItem(ctx2, value);
        },
        highlightLastItem(ctx2) {
          const value = ctx2.collection.last();
          set.highlightedItem(ctx2, value);
        },
        highlightNextItem(ctx2) {
          const value = ctx2.collection.next(ctx2.highlightedValue) ?? (ctx2.loop ? ctx2.collection.first() : null);
          set.highlightedItem(ctx2, value);
        },
        highlightPrevItem(ctx2) {
          const value = ctx2.collection.prev(ctx2.highlightedValue) ?? (ctx2.loop ? ctx2.collection.last() : null);
          set.highlightedItem(ctx2, value);
        },
        highlightFirstSelectedItem(ctx2) {
          const [value] = ctx2.collection.sort(ctx2.value);
          set.highlightedItem(ctx2, value);
        },
        autofillInputValue(ctx2, evt) {
          const inputEl = dom.getInputEl(ctx2);
          if (!ctx2.autoComplete || !inputEl || !KEYDOWN_EVENT_REGEX.test(evt.type))
            return;
          const valueText = ctx2.collection.valueToString(ctx2.highlightedValue);
          (0, import_dom_query3.raf)(() => {
            inputEl.value = valueText || ctx2.inputValue;
          });
        },
        setCollection(ctx2, evt) {
          ctx2.collection = evt.value;
        }
      }
    }
  );
}
var invoke = {
  selectionChange: (ctx) => {
    ctx.onValueChange?.({
      value: Array.from(ctx.value),
      items: ctx.selectedItems
    });
    ctx.inputValue = (0, import_utils.match)(ctx.selectionBehavior, {
      replace: ctx.valueAsString,
      clear: "",
      preserve: ctx.inputValue
    });
  },
  highlightChange: (ctx) => {
    ctx.onHighlightChange?.({
      highlightedValue: ctx.highlightedValue,
      highligtedItem: ctx.highlightedItem
    });
  },
  inputChange: (ctx) => {
    ctx.onInputValueChange?.({ value: ctx.inputValue });
  }
};
var set = {
  selectedItem: (ctx, value, force = false) => {
    if ((0, import_utils.isEqual)(ctx.value, value))
      return;
    if (value == null && !force)
      return;
    if (value == null && force) {
      ctx.value = [];
      invoke.selectionChange(ctx);
      return;
    }
    ctx.value = ctx.multiple ? (0, import_utils.addOrRemove)(ctx.value, value) : [value];
    invoke.selectionChange(ctx);
  },
  selectedItems: (ctx, value) => {
    if ((0, import_utils.isEqual)(ctx.value, value))
      return;
    ctx.value = value;
    invoke.selectionChange(ctx);
  },
  highlightedItem: (ctx, value, force = false) => {
    if ((0, import_utils.isEqual)(ctx.highlightedValue, value))
      return;
    if (!value && !force)
      return;
    ctx.highlightedValue = value || null;
    invoke.highlightChange(ctx);
  },
  inputValue: (ctx, value) => {
    if ((0, import_utils.isEqual)(ctx.inputValue, value))
      return;
    ctx.inputValue = value;
    invoke.inputChange(ctx);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  anatomy,
  collection,
  connect,
  machine
});
//# sourceMappingURL=index.js.map