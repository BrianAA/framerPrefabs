"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  anatomy: () => anatomy,
  connect: () => connect,
  machine: () => machine
});
module.exports = __toCommonJS(src_exports);

// src/tooltip.anatomy.ts
var import_anatomy = require("@zag-js/anatomy");
var anatomy = (0, import_anatomy.createAnatomy)("tooltip").parts("trigger", "arrow", "arrowTip", "positioner", "content");
var parts = anatomy.build();

// src/tooltip.connect.ts
var import_dom_query2 = require("@zag-js/dom-query");
var import_popper = require("@zag-js/popper");

// src/tooltip.dom.ts
var import_dom_query = require("@zag-js/dom-query");
var dom = (0, import_dom_query.createScope)({
  getTriggerId: (ctx) => ctx.ids?.trigger ?? `tooltip:${ctx.id}:trigger`,
  getContentId: (ctx) => ctx.ids?.content ?? `tooltip:${ctx.id}:content`,
  getArrowId: (ctx) => ctx.ids?.arrow ?? `tooltip:${ctx.id}:arrow`,
  getPositionerId: (ctx) => ctx.ids?.positioner ?? `tooltip:${ctx.id}:popper`,
  getTriggerEl: (ctx) => dom.getById(ctx, dom.getTriggerId(ctx)),
  getContentEl: (ctx) => dom.getById(ctx, dom.getContentId(ctx)),
  getPositionerEl: (ctx) => dom.getById(ctx, dom.getPositionerId(ctx)),
  getArrowEl: (ctx) => dom.getById(ctx, dom.getArrowId(ctx)),
  getScrollParent: (ctx) => (0, import_dom_query.getScrollParent)(dom.getTriggerEl(ctx))
});

// src/tooltip.store.ts
var import_core = require("@zag-js/core");
var store = (0, import_core.proxy)({
  id: null,
  prevId: null,
  setId(val) {
    this.prevId = this.id;
    this.id = val;
  }
});

// src/tooltip.connect.ts
function connect(state, send, normalize) {
  const id = state.context.id;
  const hasAriaLabel = state.context.hasAriaLabel;
  const isOpen = state.hasTag("open");
  const triggerId = dom.getTriggerId(state.context);
  const contentId = dom.getContentId(state.context);
  const isDisabled = state.context.disabled;
  const popperStyles = (0, import_popper.getPlacementStyles)({
    ...state.context.positioning,
    placement: state.context.currentPlacement
  });
  return {
    isOpen,
    open() {
      send("OPEN");
    },
    close() {
      send("CLOSE");
    },
    reposition(options = {}) {
      send({ type: "SET_POSITIONING", options });
    },
    triggerProps: normalize.button({
      ...parts.trigger.attrs,
      id: triggerId,
      dir: state.context.dir,
      "data-expanded": (0, import_dom_query2.dataAttr)(isOpen),
      "data-state": isOpen ? "open" : "closed",
      "aria-describedby": isOpen ? contentId : void 0,
      onClick() {
        send("CLICK");
      },
      onFocus() {
        if (state.event.type === "POINTER_DOWN")
          return;
        send("FOCUS");
      },
      onBlur() {
        if (id === store.id) {
          send("BLUR");
        }
      },
      onPointerDown() {
        if (isDisabled)
          return;
        if (id === store.id) {
          send("POINTER_DOWN");
        }
      },
      onPointerMove(event) {
        if (isDisabled || event.pointerType === "touch")
          return;
        send("POINTER_MOVE");
      },
      onPointerLeave() {
        if (isDisabled)
          return;
        send("POINTER_LEAVE");
      },
      onPointerCancel() {
        if (isDisabled)
          return;
        send("POINTER_LEAVE");
      }
    }),
    arrowProps: normalize.element({
      id: dom.getArrowId(state.context),
      ...parts.arrow.attrs,
      dir: state.context.dir,
      style: popperStyles.arrow
    }),
    arrowTipProps: normalize.element({
      ...parts.arrowTip.attrs,
      dir: state.context.dir,
      style: popperStyles.arrowTip
    }),
    positionerProps: normalize.element({
      id: dom.getPositionerId(state.context),
      ...parts.positioner.attrs,
      dir: state.context.dir,
      style: popperStyles.floating
    }),
    contentProps: normalize.element({
      ...parts.content.attrs,
      dir: state.context.dir,
      hidden: !isOpen,
      "data-state": isOpen ? "open" : "closed",
      role: hasAriaLabel ? void 0 : "tooltip",
      id: hasAriaLabel ? void 0 : contentId,
      "data-placement": state.context.currentPlacement,
      onPointerEnter() {
        send("CONTENT.POINTER_MOVE");
      },
      onPointerLeave() {
        send("CONTENT.POINTER_LEAVE");
      },
      style: {
        pointerEvents: state.context.interactive ? "auto" : "none"
      }
    })
  };
}

// src/tooltip.machine.ts
var import_core2 = require("@zag-js/core");
var import_dom_event = require("@zag-js/dom-event");
var import_dom_query3 = require("@zag-js/dom-query");
var import_popper2 = require("@zag-js/popper");
var import_utils = require("@zag-js/utils");
var { and, not } = import_core2.guards;
function machine(userContext) {
  const ctx = (0, import_utils.compact)(userContext);
  return (0, import_core2.createMachine)(
    {
      id: "tooltip",
      initial: "closed",
      context: {
        openDelay: 1e3,
        closeDelay: 500,
        closeOnPointerDown: true,
        closeOnEsc: true,
        interactive: true,
        currentPlacement: void 0,
        ...ctx,
        hasPointerMoveOpened: false,
        positioning: {
          placement: "bottom",
          ...ctx.positioning
        }
      },
      computed: {
        hasAriaLabel: (ctx2) => !!ctx2["aria-label"]
      },
      watch: {
        disabled: ["closeIfDisabled"],
        open: ["toggleVisibility"]
      },
      on: {
        OPEN: "open",
        CLOSE: "closed"
      },
      states: {
        closed: {
          tags: ["closed"],
          entry: ["clearGlobalId", "invokeOnClose"],
          on: {
            FOCUS: "open",
            POINTER_LEAVE: {
              actions: ["clearPointerMoveOpened"]
            },
            POINTER_MOVE: [
              {
                guard: and("noVisibleTooltip", not("hasPointerMoveOpened")),
                target: "opening"
              },
              {
                guard: not("hasPointerMoveOpened"),
                target: "open",
                actions: ["setPointerMoveOpened"]
              }
            ]
          }
        },
        opening: {
          tags: ["closed"],
          activities: ["trackScroll", "trackPointerlockChange"],
          after: {
            OPEN_DELAY: {
              target: "open",
              actions: ["setPointerMoveOpened"]
            }
          },
          on: {
            POINTER_LEAVE: {
              target: "closed",
              actions: ["clearPointerMoveOpened"]
            },
            BLUR: "closed",
            SCROLL: "closed",
            POINTER_LOCK_CHANGE: "closed",
            POINTER_DOWN: {
              guard: "closeOnPointerDown",
              target: "closed"
            }
          }
        },
        open: {
          tags: ["open"],
          activities: [
            "trackEscapeKey",
            "trackDisabledTriggerOnSafari",
            "trackScroll",
            "trackPointerlockChange",
            "trackPositioning"
          ],
          entry: ["setGlobalId", "invokeOnOpen"],
          on: {
            POINTER_LEAVE: [
              {
                guard: "isVisible",
                target: "closing",
                actions: ["clearPointerMoveOpened"]
              },
              {
                target: "closed",
                actions: ["clearPointerMoveOpened"]
              }
            ],
            BLUR: "closed",
            ESCAPE: "closed",
            SCROLL: "closed",
            POINTER_LOCK_CHANGE: "closed",
            "CONTENT.POINTER_LEAVE": {
              guard: "isInteractive",
              target: "closing"
            },
            POINTER_DOWN: {
              guard: "closeOnPointerDown",
              target: "closed"
            },
            CLICK: "closed",
            SET_POSITIONING: {
              actions: "reposition"
            }
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackStore", "trackPositioning"],
          after: {
            CLOSE_DELAY: "closed"
          },
          on: {
            FORCE_CLOSE: "closed",
            POINTER_MOVE: {
              target: "open",
              actions: ["setPointerMoveOpened"]
            },
            "CONTENT.POINTER_MOVE": {
              guard: "isInteractive",
              target: "open"
            }
          }
        }
      }
    },
    {
      activities: {
        trackPositioning(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const getPositionerEl = () => dom.getPositionerEl(ctx2);
          return (0, import_popper2.getPlacement)(dom.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            },
            onCleanup() {
              ctx2.currentPlacement = void 0;
            }
          });
        },
        trackPointerlockChange(ctx2, _evt, { send }) {
          const onChange = () => send("POINTER_LOCK_CHANGE");
          return (0, import_dom_event.addDomEvent)(dom.getDoc(ctx2), "pointerlockchange", onChange, false);
        },
        trackScroll(ctx2, _evt, { send }) {
          const trigger = dom.getTriggerEl(ctx2);
          if (!trigger)
            return;
          const cleanups = (0, import_dom_query3.getScrollParents)(trigger).map((el) => {
            const opts = { passive: true, capture: true };
            return (0, import_dom_event.addDomEvent)(el, "scroll", () => send("SCROLL"), opts);
          });
          return () => {
            cleanups.forEach((fn) => fn?.());
          };
        },
        trackStore(ctx2, _evt, { send }) {
          return (0, import_core2.subscribe)(store, () => {
            if (store.id !== ctx2.id) {
              send("FORCE_CLOSE");
            }
          });
        },
        trackDisabledTriggerOnSafari(ctx2, _evt, { send }) {
          if (!(0, import_dom_query3.isSafari)())
            return;
          const doc = dom.getDoc(ctx2);
          return (0, import_dom_event.addDomEvent)(doc, "pointermove", (event) => {
            const selector = "[data-part=trigger][data-expanded]";
            if ((0, import_dom_query3.isHTMLElement)(event.target) && event.target.closest(selector))
              return;
            send("POINTER_LEAVE");
          });
        },
        trackEscapeKey(ctx2, _evt, { send }) {
          if (!ctx2.closeOnEsc)
            return;
          const doc = dom.getDoc(ctx2);
          return (0, import_dom_event.addDomEvent)(doc, "keydown", (event) => {
            if (event.key === "Escape") {
              send("ESCAPE");
            }
          });
        }
      },
      actions: {
        setGlobalId(ctx2) {
          store.setId(ctx2.id);
        },
        clearGlobalId(ctx2) {
          if (ctx2.id === store.id) {
            store.setId(null);
          }
        },
        invokeOnOpen(ctx2, evt) {
          const omit = ["CONTENT.POINTER_MOVE", "POINTER_MOVE"];
          if (!omit.includes(evt.type)) {
            ctx2.onOpenChange?.({ open: true });
          }
        },
        invokeOnClose(ctx2) {
          ctx2.onOpenChange?.({ open: false });
        },
        closeIfDisabled(ctx2, _evt, { send }) {
          if (!ctx2.disabled)
            return;
          send("CLOSE");
        },
        reposition(ctx2, evt) {
          const getPositionerEl = () => dom.getPositionerEl(ctx2);
          (0, import_popper2.getPlacement)(dom.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        toggleVisibility(ctx2, _evt, { send }) {
          send({ type: ctx2.open ? "OPEN" : "CLOSE", src: "controlled" });
        },
        setPointerMoveOpened(ctx2) {
          ctx2.hasPointerMoveOpened = true;
        },
        clearPointerMoveOpened(ctx2) {
          ctx2.hasPointerMoveOpened = false;
        }
      },
      guards: {
        closeOnPointerDown: (ctx2) => ctx2.closeOnPointerDown,
        noVisibleTooltip: () => store.id === null,
        isVisible: (ctx2) => ctx2.id === store.id,
        isInteractive: (ctx2) => ctx2.interactive,
        hasPointerMoveOpened: (ctx2) => !!ctx2.hasPointerMoveOpened
      },
      delays: {
        OPEN_DELAY: (ctx2) => ctx2.openDelay,
        CLOSE_DELAY: (ctx2) => ctx2.closeDelay
      }
    }
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  anatomy,
  connect,
  machine
});
//# sourceMappingURL=index.js.map