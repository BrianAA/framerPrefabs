declare function toArray<T>(v: T | T[] | undefined | null): T[];
declare const fromLength: (length: number) => number[];
declare const first: <T>(v: T[]) => T | undefined;
declare const last: <T>(v: T[]) => T | undefined;
declare const isEmpty: <T>(v: T[]) => boolean;
declare const has: <T>(v: T[], t: any) => boolean;
declare const add: <T>(v: T[], ...items: T[]) => T[];
declare const remove: <T>(v: T[], item: T) => T[];
declare const removeAt: <T>(v: T[], i: number) => T[];
declare const addOrRemove: <T>(v: T[], item: T) => T[];
declare function clear<T>(v: T[]): T[];
type IndexOptions = {
    step?: number;
    loop?: boolean;
};
declare function nextIndex<T>(v: T[], idx: number, opts?: IndexOptions): number;
declare function next<T>(v: T[], idx: number, opts?: IndexOptions): T | undefined;
declare function prevIndex<T>(v: T[], idx: number, opts?: IndexOptions): number;
declare function prev<T>(v: T[], index: number, opts?: IndexOptions): T | undefined;
declare const chunk: <T>(v: T[], size: number) => T[][];

declare const isEqual: (a: any, b: any) => boolean;

type MaybeFunction<T> = T | (() => T);
type Nullable<T> = T | null | undefined;
declare const runIfFn: <T>(v: T | undefined, ...a: T extends (...a: any[]) => void ? Parameters<T> : never) => T extends (...a: any[]) => void ? NonNullable<ReturnType<T>> : NonNullable<T>;
declare const cast: <T>(v: unknown) => T;
declare const noop: () => void;
declare const callAll: <T extends (...a: any[]) => void>(...fns: (T | undefined)[]) => (...a: Parameters<T>) => void;
declare const uuid: () => string;
declare function match<V extends string | number = string, R = unknown>(key: V, record: Record<V, R | ((...args: any[]) => R)>, ...args: any[]): R;
declare const tryCatch: <R>(fn: () => R, fallback: () => R) => R;

declare const isDev: () => boolean;
declare const isArray: (v: any) => v is any[];
declare const isBoolean: (v: any) => v is boolean;
declare const isObject: (v: any) => v is Record<string, any>;
declare const isNumber: (v: any) => v is number;
declare const isString: (v: any) => v is string;
declare const isFunction: (v: any) => v is Function;
declare const isNull: (v: any) => v is null | undefined;
declare const hasProp: <T extends string>(obj: any, prop: T) => obj is Record<T, any>;

declare function compact<T extends Record<string, unknown> | undefined>(obj: T): T;
declare function json(value: any): any;

declare function warn(m: string): void;
declare function warn(c: boolean, m: string): void;
declare function invariant(m: string): void;
declare function invariant(c: boolean, m: string): void;

export { type IndexOptions, type MaybeFunction, type Nullable, add, addOrRemove, callAll, cast, chunk, clear, compact, first, fromLength, has, hasProp, invariant, isArray, isBoolean, isDev, isEmpty, isEqual, isFunction, isNull, isNumber, isObject, isString, json, last, match, next, nextIndex, noop, prev, prevIndex, remove, removeAt, runIfFn, toArray, tryCatch, uuid, warn };
