interface CollectionSearchState {
    keysSoFar: string;
    timer: number;
}
interface CollectionSearchOptions {
    state: CollectionSearchState;
    currentValue: string | null;
    timeout?: number;
}
type CollectionItem = any;
interface CollectionNode<T extends CollectionItem = CollectionItem> {
    item: T;
    index: number;
    label: string;
    value: string;
    previousValue: string | null;
    nextValue: string | null;
}
interface CollectionOptions<T extends CollectionItem = CollectionItem> {
    /**
     * The options of the select
     */
    items: T[] | readonly T[];
    /**
     * The value of the item
     */
    itemToValue?: (item: T) => string;
    /**
     * The label of the item
     */
    itemToString?: (item: T) => string;
    /**
     * Whether the item is disabled
     */
    isItemDisabled?: (item: T) => boolean;
}

declare class Collection<T extends CollectionItem = CollectionItem> {
    private options;
    /**
     * The collection nodes
     */
    private nodes;
    /**
     * The set of disabled values
     */
    private disabledValues;
    /**
     * The first value in the collection (without accounting for disabled items)
     */
    private _firstValue;
    /**
     * The last value in the collection (without accounting for disabled items)
     */
    private _lastValue;
    private hash;
    constructor(options: CollectionOptions<T>);
    isEqual: (other: Collection<T>) => boolean;
    /**
     * Iterate over the collection items and create a map of nodes
     */
    private iterate;
    /**
     * Function to update the collection items
     */
    setItems: (items: T[] | readonly T[]) => Collection<T>;
    /**
     * Get the item based on its value
     */
    item: (value: string | null) => T | null;
    /**
     * Get the items based on its values
     */
    items: (values: string[]) => T[];
    /**
     * Get the item based on its index
     */
    at: (index: number) => T | null;
    private sortFn;
    /**
     * Sort the values based on their index
     */
    sort: (values: string[]) => string[];
    /**
     * Convert an item to a value
     */
    itemToValue: (item: T) => string;
    /**
     * Convert an item to a string
     */
    itemToString: (item: T | null) => string;
    /**
     * Whether an item is disabled
     */
    itemToDisabled: (item: T | null) => boolean;
    /**
     * Convert a value to a string
     */
    valueToString: (value: string | null) => string;
    /**
     * Convert an array of items to a string
     */
    itemsToString: (item: T[], separator?: string) => string;
    /**
     * Whether the collection has a value
     */
    has: (value: string | null) => boolean;
    /**
     * Returns the number of items in the collection
     */
    count: () => number;
    /**
     * Returns the first value in the collection
     */
    first: () => string | null;
    /**
     * Returns the last value in the collection
     */
    last: () => string | null;
    /**
     * Returns the next value in the collection
     */
    next: (value: string | null) => string | null;
    /**
     * Returns the previous value in the collection
     */
    prev: (value: string | null) => string | null;
    /**
     * Whether an item is disabled
     */
    isItemDisabled: (item: T) => boolean;
    /**
     * Returns the array of collection nodes
     */
    toArray: () => CollectionNode<T>[];
    /**
     * Get the index of an item based on its key
     */
    indexOf: (value: string | null) => number;
    private getByText;
    /**
     * Search for a value based on a query
     */
    search: (queryString: string, options: CollectionSearchOptions) => string | null;
    toJSON: () => {
        size: number;
        first: string | null;
        last: string | null;
    };
}

export { Collection, type CollectionItem, type CollectionNode, type CollectionOptions, type CollectionSearchOptions, type CollectionSearchState };
