var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/hash.ts
function hash(str) {
  let i;
  let l;
  let hval = 2166136261;
  for (i = 0, l = str.length; i < l; i++) {
    hval ^= str.charCodeAt(i);
    hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
  }
  return `00000${(hval >>> 0).toString(36)}`.slice(-6);
}

// src/collection.ts
var isObject = (v) => typeof v === "object" && v !== null && !Array.isArray(v);
var hasKey = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
var fallback = {
  itemToValue(item) {
    if (typeof item === "string")
      return item;
    if (isObject(item) && hasKey(item, "value"))
      return item.value;
    return "";
  },
  itemToString(item) {
    if (typeof item === "string")
      return item;
    if (isObject(item) && hasKey(item, "label"))
      return item.label;
    return fallback.itemToValue(item);
  },
  itemToDisabled(item) {
    if (isObject(item) && hasKey(item, "disabled"))
      return !!item.disabled;
    return false;
  }
};
var Collection = class {
  constructor(options) {
    this.options = options;
    /**
     * The collection nodes
     */
    __publicField(this, "nodes", /* @__PURE__ */ new Map());
    /**
     * The set of disabled values
     */
    __publicField(this, "disabledValues", /* @__PURE__ */ new Set());
    /**
     * The first value in the collection (without accounting for disabled items)
     */
    __publicField(this, "_firstValue", null);
    /**
     * The last value in the collection (without accounting for disabled items)
     */
    __publicField(this, "_lastValue", null);
    __publicField(this, "hash", "");
    __publicField(this, "isEqual", (other) => {
      return this.hash === other.hash;
    });
    /**
     * Iterate over the collection items and create a map of nodes
     */
    __publicField(this, "iterate", () => {
      const { items } = this.options;
      const hashSet = /* @__PURE__ */ new Set();
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const value = this.itemToValue(item);
        const label = this.itemToString(item);
        const disabled = this.itemToDisabled(item);
        hashSet.add(value);
        const node = {
          // freeze item to prevent mutation by frameworks like Solid.js
          item: Object.freeze(item),
          index: i,
          label,
          value,
          previousValue: this.itemToValue(items[i - 1]) ?? null,
          nextValue: this.itemToValue(items[i + 1]) ?? null
        };
        this.nodes.set(value, node);
        if (disabled) {
          this.disabledValues.add(value);
        }
        if (i === 0) {
          this._firstValue = value;
        }
        if (i === items.length - 1) {
          this._lastValue = value;
        }
      }
      this.hash = hash(Array.from(hashSet).join(""));
      return this;
    });
    /**
     * Function to update the collection items
     */
    __publicField(this, "setItems", (items) => {
      this.options.items = items;
      return this.iterate();
    });
    /**
     * Get the item based on its value
     */
    __publicField(this, "item", (value) => {
      if (value === null)
        return null;
      return this.nodes.get(value)?.item ?? null;
    });
    /**
     * Get the items based on its values
     */
    __publicField(this, "items", (values) => {
      return values.map((value) => this.item(value)).filter(Boolean);
    });
    /**
     * Get the item based on its index
     */
    __publicField(this, "at", (index) => {
      for (const node of this.nodes.values()) {
        if (node.index === index) {
          return node.item;
        }
      }
      return null;
    });
    __publicField(this, "sortFn", (valueA, valueB) => {
      const nodeA = this.nodes.get(valueA);
      const nodeB = this.nodes.get(valueB);
      return (nodeA?.index ?? 0) - (nodeB?.index ?? 0);
    });
    /**
     * Sort the values based on their index
     */
    __publicField(this, "sort", (values) => {
      return values.sort(this.sortFn);
    });
    /**
     * Convert an item to a value
     */
    __publicField(this, "itemToValue", (item) => {
      if (!item)
        return "";
      return this.options.itemToValue?.(item) ?? fallback.itemToValue(item);
    });
    /**
     * Convert an item to a string
     */
    __publicField(this, "itemToString", (item) => {
      if (!item)
        return "";
      return this.options.itemToString?.(item) ?? fallback.itemToString(item);
    });
    /**
     * Whether an item is disabled
     */
    __publicField(this, "itemToDisabled", (item) => {
      if (!item)
        return false;
      return this.options.isItemDisabled?.(item) ?? fallback.itemToDisabled(item);
    });
    /**
     * Convert a value to a string
     */
    __publicField(this, "valueToString", (value) => {
      if (value == null)
        return "";
      return this.nodes.get(value)?.label ?? "";
    });
    /**
     * Convert an array of items to a string
     */
    __publicField(this, "itemsToString", (item, separator = ", ") => {
      return item.map((item2) => this.itemToString(item2)).filter(Boolean).join(separator);
    });
    /**
     * Whether the collection has a value
     */
    __publicField(this, "has", (value) => {
      if (value == null)
        return false;
      return this.nodes.has(value);
    });
    /**
     * Returns the number of items in the collection
     */
    __publicField(this, "count", () => {
      return this.nodes.size;
    });
    /**
     * Returns the first value in the collection
     */
    __publicField(this, "first", () => {
      let firstValue = this._firstValue;
      while (firstValue != null) {
        let item = this.nodes.get(firstValue);
        if (item != null && !this.disabledValues.has(item.value)) {
          return firstValue;
        }
        firstValue = item?.nextValue ?? null;
      }
      return null;
    });
    /**
     * Returns the last value in the collection
     */
    __publicField(this, "last", () => {
      let lastValue = this._lastValue;
      while (lastValue != null) {
        let item = this.nodes.get(lastValue);
        if (item != null && !this.disabledValues.has(item.value)) {
          return lastValue;
        }
        lastValue = item?.previousValue ?? null;
      }
      return null;
    });
    /**
     * Returns the next value in the collection
     */
    __publicField(this, "next", (value) => {
      if (value == null)
        return null;
      const item = this.nodes.get(value);
      let nextValue = item?.nextValue ?? null;
      while (nextValue != null) {
        let item2 = this.nodes.get(nextValue);
        if (item2 != null && !this.disabledValues.has(item2.value)) {
          return nextValue;
        }
        nextValue = item2?.nextValue ?? null;
      }
      return null;
    });
    /**
     * Returns the previous value in the collection
     */
    __publicField(this, "prev", (value) => {
      if (value == null)
        return null;
      const item = this.nodes.get(value);
      let previousValue = item?.previousValue ?? null;
      while (previousValue != null) {
        let item2 = this.nodes.get(previousValue);
        if (item2 != null && !this.disabledValues.has(item2.value)) {
          return previousValue;
        }
        previousValue = item2?.previousValue ?? null;
      }
      return null;
    });
    /**
     * Whether an item is disabled
     */
    __publicField(this, "isItemDisabled", (item) => {
      return this.disabledValues.has(this.itemToValue(item));
    });
    /**
     * Returns the array of collection nodes
     */
    __publicField(this, "toArray", () => {
      return Array.from(this.nodes.values());
    });
    /**
     * Get the index of an item based on its key
     */
    __publicField(this, "indexOf", (value) => {
      if (value == null)
        return -1;
      return this.nodes.get(value)?.index ?? -1;
    });
    __publicField(this, "getByText", (text, currentValue) => {
      const index = this.indexOf(currentValue);
      let nodes = currentValue != null ? wrap(this.toArray(), index) : this.toArray();
      const isSingleKey = text.length === 1;
      if (isSingleKey) {
        nodes = nodes.filter((node) => node.value !== currentValue);
      }
      return nodes.find((node) => match(node.label, text));
    });
    /**
     * Search for a value based on a query
     */
    __publicField(this, "search", (queryString, options) => {
      const { state, currentValue, timeout = 350 } = options;
      const search = state.keysSoFar + queryString;
      const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
      const query = isRepeated ? search[0] : search;
      const value = this.getByText(query, currentValue)?.value ?? null;
      function cleanup() {
        clearTimeout(state.timer);
        state.timer = -1;
      }
      function update(value2) {
        state.keysSoFar = value2;
        cleanup();
        if (value2 !== "") {
          state.timer = +setTimeout(() => {
            update("");
            cleanup();
          }, timeout);
        }
      }
      update(search);
      return value;
    });
    __publicField(this, "toJSON", () => {
      return {
        size: this.count(),
        first: this.first(),
        last: this.last()
      };
    });
    this.iterate();
  }
};
var match = (label, query) => {
  return label.toLowerCase().startsWith(query.toLowerCase());
};
var wrap = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
export {
  Collection
};
//# sourceMappingURL=index.mjs.map