{"version":3,"sources":["../src/hash.ts","../src/collection.ts"],"sourcesContent":["export function hash(str: string) {\n  let i\n  let l\n  let hval = 2166136261\n\n  for (i = 0, l = str.length; i < l; i++) {\n    hval ^= str.charCodeAt(i)\n    hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24)\n  }\n  return `00000${(hval >>> 0).toString(36)}`.slice(-6)\n}\n","import { hash } from \"./hash\"\nimport type { CollectionItem, CollectionNode, CollectionOptions, CollectionSearchOptions } from \"./types\"\n\nconst isObject = (v: any): v is Record<string, any> => typeof v === \"object\" && v !== null && !Array.isArray(v)\n\nconst hasKey = <T>(obj: T, key: string): obj is T & Record<string, any> =>\n  Object.prototype.hasOwnProperty.call(obj, key)\n\nconst fallback = {\n  itemToValue(item: any) {\n    if (typeof item === \"string\") return item\n    if (isObject(item) && hasKey(item, \"value\")) return item.value\n    return \"\"\n  },\n  itemToString(item: any) {\n    if (typeof item === \"string\") return item\n    if (isObject(item) && hasKey(item, \"label\")) return item.label\n    return fallback.itemToValue(item)\n  },\n  itemToDisabled(item: any) {\n    if (isObject(item) && hasKey(item, \"disabled\")) return !!item.disabled\n    return false\n  },\n}\n\nexport class Collection<T extends CollectionItem = CollectionItem> {\n  /**\n   * The collection nodes\n   */\n  private nodes = new Map<string, CollectionNode<T>>()\n\n  /**\n   * The set of disabled values\n   */\n  private disabledValues = new Set<string>()\n\n  /**\n   * The first value in the collection (without accounting for disabled items)\n   */\n  private _firstValue: string | null = null\n\n  /**\n   * The last value in the collection (without accounting for disabled items)\n   */\n  private _lastValue: string | null = null\n\n  private hash: string = \"\"\n\n  constructor(private options: CollectionOptions<T>) {\n    this.iterate()\n  }\n\n  isEqual = (other: Collection<T>) => {\n    return this.hash === other.hash\n  }\n\n  /**\n   * Iterate over the collection items and create a map of nodes\n   */\n  private iterate = (): Collection<T> => {\n    const { items } = this.options\n\n    const hashSet = new Set<string>()\n\n    for (let i = 0; i < items.length; i++) {\n      const item = items[i]\n\n      const value = this.itemToValue(item)\n      const label = this.itemToString(item)\n      const disabled = this.itemToDisabled(item)\n\n      hashSet.add(value)\n\n      const node: CollectionNode<T> = {\n        // freeze item to prevent mutation by frameworks like Solid.js\n        item: Object.freeze(item),\n        index: i,\n        label,\n        value: value,\n        previousValue: this.itemToValue(items[i - 1]) ?? null,\n        nextValue: this.itemToValue(items[i + 1]) ?? null,\n      }\n\n      this.nodes.set(value, node)\n\n      if (disabled) {\n        this.disabledValues.add(value)\n      }\n\n      if (i === 0) {\n        this._firstValue = value\n      }\n\n      if (i === items.length - 1) {\n        this._lastValue = value\n      }\n    }\n\n    this.hash = hash(Array.from(hashSet).join(\"\"))\n\n    return this\n  }\n\n  /**\n   * Function to update the collection items\n   */\n  setItems = (items: T[] | readonly T[]) => {\n    this.options.items = items\n    return this.iterate()\n  }\n\n  /**\n   * Get the item based on its value\n   */\n  item = (value: string | null): T | null => {\n    if (value === null) return null\n    return this.nodes.get(value)?.item ?? null\n  }\n\n  /**\n   * Get the items based on its values\n   */\n  items = (values: string[]): T[] => {\n    return values.map((value) => this.item(value)!).filter(Boolean)\n  }\n\n  /**\n   * Get the item based on its index\n   */\n  at = (index: number): T | null => {\n    for (const node of this.nodes.values()) {\n      if (node.index === index) {\n        return node.item\n      }\n    }\n    return null\n  }\n\n  private sortFn = (valueA: string, valueB: string): number => {\n    const nodeA = this.nodes.get(valueA)\n    const nodeB = this.nodes.get(valueB)\n    return (nodeA?.index ?? 0) - (nodeB?.index ?? 0)\n  }\n\n  /**\n   * Sort the values based on their index\n   */\n  sort = (values: string[]): string[] => {\n    return values.sort(this.sortFn)\n  }\n\n  /**\n   * Convert an item to a value\n   */\n  itemToValue = (item: T): string => {\n    if (!item) return \"\"\n    return this.options.itemToValue?.(item) ?? fallback.itemToValue(item)\n  }\n\n  /**\n   * Convert an item to a string\n   */\n  itemToString = (item: T | null): string => {\n    if (!item) return \"\"\n    return this.options.itemToString?.(item) ?? fallback.itemToString(item)\n  }\n\n  /**\n   * Whether an item is disabled\n   */\n  itemToDisabled = (item: T | null): boolean => {\n    if (!item) return false\n    return this.options.isItemDisabled?.(item) ?? fallback.itemToDisabled(item)\n  }\n\n  /**\n   * Convert a value to a string\n   */\n  valueToString = (value: string | null): string => {\n    if (value == null) return \"\"\n    return this.nodes.get(value)?.label ?? \"\"\n  }\n\n  /**\n   * Convert an array of items to a string\n   */\n  itemsToString = (item: T[], separator = \", \"): string => {\n    return item\n      .map((item) => this.itemToString(item))\n      .filter(Boolean)\n      .join(separator)\n  }\n\n  /**\n   * Whether the collection has a value\n   */\n  has = (value: string | null): boolean => {\n    if (value == null) return false\n    return this.nodes.has(value)\n  }\n\n  /**\n   * Returns the number of items in the collection\n   */\n  count = (): number => {\n    return this.nodes.size\n  }\n\n  /**\n   * Returns the first value in the collection\n   */\n  first = (): string | null => {\n    let firstValue = this._firstValue\n    while (firstValue != null) {\n      let item = this.nodes.get(firstValue)\n      if (item != null && !this.disabledValues.has(item.value)) {\n        return firstValue\n      }\n      firstValue = item?.nextValue ?? null\n    }\n    return null\n  }\n\n  /**\n   * Returns the last value in the collection\n   */\n  last = (): string | null => {\n    let lastValue = this._lastValue\n    while (lastValue != null) {\n      let item = this.nodes.get(lastValue)\n      if (item != null && !this.disabledValues.has(item.value)) {\n        return lastValue\n      }\n      lastValue = item?.previousValue ?? null\n    }\n    return null\n  }\n\n  /**\n   * Returns the next value in the collection\n   */\n  next = (value: string | null): string | null => {\n    if (value == null) return null\n\n    const item = this.nodes.get(value)\n    let nextValue = item?.nextValue ?? null\n\n    while (nextValue != null) {\n      let item = this.nodes.get(nextValue)\n      if (item != null && !this.disabledValues.has(item.value)) {\n        return nextValue\n      }\n      nextValue = item?.nextValue ?? null\n    }\n    return null\n  }\n\n  /**\n   * Returns the previous value in the collection\n   */\n  prev = (value: string | null): string | null => {\n    if (value == null) return null\n\n    const item = this.nodes.get(value)\n    let previousValue = item?.previousValue ?? null\n\n    while (previousValue != null) {\n      let item = this.nodes.get(previousValue)\n      if (item != null && !this.disabledValues.has(item.value)) {\n        return previousValue\n      }\n      previousValue = item?.previousValue ?? null\n    }\n    return null\n  }\n\n  /**\n   * Whether an item is disabled\n   */\n  isItemDisabled = (item: T): boolean => {\n    return this.disabledValues.has(this.itemToValue(item))\n  }\n\n  /**\n   * Returns the array of collection nodes\n   */\n  toArray = (): CollectionNode<T>[] => {\n    return Array.from(this.nodes.values())\n  }\n\n  /**\n   * Get the index of an item based on its key\n   */\n  indexOf = (value: string | null): number => {\n    if (value == null) return -1\n    return this.nodes.get(value)?.index ?? -1\n  }\n\n  private getByText = (text: string, currentValue: string | null): CollectionNode<T> | undefined => {\n    const index = this.indexOf(currentValue)\n    let nodes = currentValue != null ? wrap(this.toArray(), index) : this.toArray()\n\n    const isSingleKey = text.length === 1\n\n    if (isSingleKey) {\n      nodes = nodes.filter((node) => node.value !== currentValue)\n    }\n\n    return nodes.find((node) => match(node.label, text))\n  }\n\n  /**\n   * Search for a value based on a query\n   */\n  search = (queryString: string, options: CollectionSearchOptions): string | null => {\n    const { state, currentValue, timeout = 350 } = options\n\n    const search = state.keysSoFar + queryString\n    const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0])\n\n    const query = isRepeated ? search[0] : search\n\n    const value = this.getByText(query, currentValue)?.value ?? null\n\n    function cleanup() {\n      clearTimeout(state.timer)\n      state.timer = -1\n    }\n\n    function update(value: string) {\n      state.keysSoFar = value\n      cleanup()\n\n      if (value !== \"\") {\n        state.timer = +setTimeout(() => {\n          update(\"\")\n          cleanup()\n        }, timeout)\n      }\n    }\n\n    update(search)\n\n    return value\n  }\n\n  toJSON = () => {\n    return {\n      size: this.count(),\n      first: this.first(),\n      last: this.last(),\n    }\n  }\n}\n\nconst match = (label: string, query: string) => {\n  return label.toLowerCase().startsWith(query.toLowerCase())\n}\n\nconst wrap = <T>(v: T[], idx: number) => {\n  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length])\n}\n"],"mappings":"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","names":["item","value"]}