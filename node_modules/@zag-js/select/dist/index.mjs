// src/select.anatomy.ts
import { createAnatomy } from "@zag-js/anatomy";
var anatomy = createAnatomy("select").parts(
  "label",
  "positioner",
  "trigger",
  "indicator",
  "clearTrigger",
  "item",
  "itemText",
  "itemIndicator",
  "itemGroup",
  "itemGroupLabel",
  "content",
  "root",
  "control"
);
var parts = anatomy.build();

// src/select.collection.ts
import { Collection } from "@zag-js/collection";
import { ref } from "@zag-js/core";
var collection = (options) => {
  return ref(new Collection(options));
};
collection.empty = () => {
  return ref(new Collection({ items: [] }));
};

// src/select.connect.ts
import { getEventKey } from "@zag-js/dom-event";
import { ariaAttr, dataAttr, getByTypeahead, isEditableElement, isSelfEvent } from "@zag-js/dom-query";
import { getPlacementStyles } from "@zag-js/popper";
import { visuallyHiddenStyle } from "@zag-js/visually-hidden";

// src/select.dom.ts
import { createScope } from "@zag-js/dom-query";
var dom = createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `select:${ctx.id}`,
  getContentId: (ctx) => ctx.ids?.content ?? `select:${ctx.id}:content`,
  getTriggerId: (ctx) => ctx.ids?.trigger ?? `select:${ctx.id}:trigger`,
  getClearTriggerId: (ctx) => ctx.ids?.clearTrigger ?? `select:${ctx.id}:clear-trigger`,
  getLabelId: (ctx) => ctx.ids?.label ?? `select:${ctx.id}:label`,
  getControlId: (ctx) => ctx.ids?.control ?? `select:${ctx.id}:control`,
  getItemId: (ctx, id) => ctx.ids?.item?.(id) ?? `select:${ctx.id}:option:${id}`,
  getHiddenSelectId: (ctx) => ctx.ids?.hiddenSelect ?? `select:${ctx.id}:select`,
  getPositionerId: (ctx) => ctx.ids?.positioner ?? `select:${ctx.id}:positioner`,
  getItemGroupId: (ctx, id) => ctx.ids?.itemGroup?.(id) ?? `select:${ctx.id}:optgroup:${id}`,
  getItemGroupLabelId: (ctx, id) => ctx.ids?.itemGroupLabel?.(id) ?? `select:${ctx.id}:optgroup-label:${id}`,
  getHiddenSelectEl: (ctx) => dom.getById(ctx, dom.getHiddenSelectId(ctx)),
  getContentEl: (ctx) => dom.getById(ctx, dom.getContentId(ctx)),
  getControlEl: (ctx) => dom.getById(ctx, dom.getControlId(ctx)),
  getTriggerEl: (ctx) => dom.getById(ctx, dom.getTriggerId(ctx)),
  getClearTriggerEl: (ctx) => dom.getById(ctx, dom.getClearTriggerId(ctx)),
  getPositionerEl: (ctx) => dom.getById(ctx, dom.getPositionerId(ctx)),
  getHighlightedOptionEl(ctx) {
    if (!ctx.highlightedValue)
      return null;
    return dom.getById(ctx, dom.getItemId(ctx, ctx.highlightedValue));
  }
});

// src/select.connect.ts
function connect(state, send, normalize) {
  const isDisabled = state.context.isDisabled;
  const isInvalid = state.context.invalid;
  const isReadOnly = state.context.readOnly;
  const isInteractive = state.context.isInteractive;
  const isOpen = state.hasTag("open");
  const isFocused = state.matches("focused");
  const highlightedItem = state.context.highlightedItem;
  const selectedItems = state.context.selectedItems;
  const isTypingAhead = state.context.isTypingAhead;
  function getItemState(props) {
    const { item } = props;
    const disabled = state.context.collection.isItemDisabled(item);
    const value = state.context.collection.itemToValue(item);
    return {
      value,
      isDisabled: Boolean(disabled || isDisabled),
      isHighlighted: state.context.highlightedValue === value,
      isSelected: state.context.value.includes(value)
    };
  }
  const popperStyles = getPlacementStyles({
    ...state.context.positioning,
    placement: state.context.currentPlacement
  });
  return {
    isOpen,
    isFocused,
    highlightedItem,
    highlightedValue: state.context.highlightedValue,
    selectedItems,
    hasSelectedItems: state.context.hasSelectedItems,
    value: state.context.value,
    valueAsString: state.context.valueAsString,
    collection: state.context.collection,
    setCollection(collection2) {
      send({ type: "COLLECTION.SET", value: collection2 });
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    focus() {
      dom.getTriggerEl(state.context)?.focus({ preventScroll: true });
    },
    open() {
      send("OPEN");
    },
    close() {
      send("CLOSE");
    },
    selectValue(value) {
      send({ type: "ITEM.SELECT", value });
    },
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    highlightValue(value) {
      send({ type: "HIGHLIGHTED_VALUE.SET", value });
    },
    clearValue(value) {
      if (value) {
        send({ type: "ITEM.CLEAR", value });
      } else {
        send({ type: "VALUE.CLEAR" });
      }
    },
    getItemState,
    rootProps: normalize.element({
      ...parts.root.attrs,
      dir: state.context.dir,
      id: dom.getRootId(state.context),
      "data-invalid": dataAttr(isInvalid),
      "data-readonly": dataAttr(isReadOnly)
    }),
    labelProps: normalize.label({
      dir: state.context.dir,
      id: dom.getLabelId(state.context),
      ...parts.label.attrs,
      "data-disabled": dataAttr(isDisabled),
      "data-invalid": dataAttr(isInvalid),
      "data-readonly": dataAttr(isReadOnly),
      htmlFor: dom.getHiddenSelectId(state.context),
      onClick() {
        if (isDisabled)
          return;
        dom.getTriggerEl(state.context)?.focus({ preventScroll: true });
      }
    }),
    controlProps: normalize.element({
      ...parts.control.attrs,
      dir: state.context.dir,
      id: dom.getControlId(state.context),
      "data-state": isOpen ? "open" : "closed",
      "data-focus": dataAttr(isFocused),
      "data-disabled": dataAttr(isDisabled),
      "data-invalid": dataAttr(isInvalid)
    }),
    triggerProps: normalize.button({
      id: dom.getTriggerId(state.context),
      disabled: isDisabled,
      dir: state.context.dir,
      type: "button",
      "aria-controls": dom.getContentId(state.context),
      "aria-expanded": isOpen,
      "data-state": isOpen ? "open" : "closed",
      "aria-haspopup": "listbox",
      "aria-labelledby": dom.getLabelId(state.context),
      ...parts.trigger.attrs,
      "data-disabled": dataAttr(isDisabled),
      "data-invalid": dataAttr(isInvalid),
      "aria-invalid": isInvalid,
      "data-readonly": dataAttr(isReadOnly),
      "data-placement": state.context.currentPlacement,
      "data-placeholder-shown": dataAttr(!state.context.hasSelectedItems),
      onPointerDown(event) {
        if (event.button || event.ctrlKey || !isInteractive)
          return;
        event.currentTarget.dataset.pointerType = event.pointerType;
        if (isDisabled || event.pointerType === "touch")
          return;
        send({ type: "TRIGGER.CLICK" });
      },
      onClick(event) {
        if (!isInteractive || event.button)
          return;
        if (event.currentTarget.dataset.pointerType === "touch") {
          send({ type: "TRIGGER.CLICK" });
        }
      },
      onFocus() {
        send("TRIGGER.FOCUS");
      },
      onBlur() {
        send("TRIGGER.BLUR");
      },
      onKeyDown(event) {
        if (!isInteractive)
          return;
        const keyMap = {
          ArrowUp() {
            send({ type: "TRIGGER.ARROW_UP" });
          },
          ArrowDown(event2) {
            send({ type: event2.altKey ? "OPEN" : "TRIGGER.ARROW_DOWN" });
          },
          ArrowLeft() {
            send({ type: "TRIGGER.ARROW_LEFT" });
          },
          ArrowRight() {
            send({ type: "TRIGGER.ARROW_RIGHT" });
          },
          Home() {
            send({ type: "TRIGGER.HOME" });
          },
          End() {
            send({ type: "TRIGGER.END" });
          },
          Enter() {
            send({ type: "TRIGGER.ENTER" });
          },
          Space(event2) {
            if (isTypingAhead) {
              send({ type: "TRIGGER.TYPEAHEAD", key: event2.key });
            } else {
              send({ type: "TRIGGER.ENTER" });
            }
          }
        };
        const exec = keyMap[getEventKey(event, state.context)];
        if (exec) {
          exec(event);
          event.preventDefault();
          return;
        }
        if (getByTypeahead.isValidEvent(event)) {
          send({ type: "TRIGGER.TYPEAHEAD", key: event.key });
          event.preventDefault();
        }
      }
    }),
    indicatorProps: normalize.element({
      ...parts.indicator.attrs,
      dir: state.context.dir,
      "aria-hidden": true,
      "data-state": isOpen ? "open" : "closed"
    }),
    getItemProps(props) {
      const itemState = getItemState(props);
      return normalize.element({
        id: dom.getItemId(state.context, itemState.value),
        role: "option",
        ...parts.item.attrs,
        dir: state.context.dir,
        "data-value": itemState.value,
        "aria-selected": itemState.isSelected,
        "data-state": itemState.isSelected ? "checked" : "unchecked",
        "data-highlighted": dataAttr(itemState.isHighlighted),
        "data-disabled": dataAttr(itemState.isDisabled),
        "aria-disabled": ariaAttr(itemState.isDisabled),
        onPointerMove(event) {
          if (itemState.isDisabled || event.pointerType !== "mouse")
            return;
          if (itemState.value === state.context.highlightedValue)
            return;
          send({ type: "ITEM.POINTER_MOVE", value: itemState.value });
        },
        onPointerUp() {
          if (itemState.isDisabled)
            return;
          send({ type: "ITEM.CLICK", src: "pointerup", value: itemState.value });
        },
        onPointerLeave(event) {
          const isKeyboardNavigationEvent = ["CONTENT.ARROW_UP", "CONTENT.ARROW_DOWN"].includes(state.event.type);
          if (itemState.isDisabled || event.pointerType !== "mouse" || isKeyboardNavigationEvent)
            return;
          send({ type: "ITEM.POINTER_LEAVE" });
        }
      });
    },
    getItemTextProps(props) {
      const itemState = getItemState(props);
      return normalize.element({
        ...parts.itemText.attrs,
        dir: state.context.dir,
        "data-disabled": dataAttr(itemState.isDisabled),
        "data-highlighted": dataAttr(itemState.isHighlighted)
      });
    },
    getItemIndicatorProps(props) {
      const itemState = getItemState(props);
      return normalize.element({
        "aria-hidden": true,
        ...parts.itemIndicator.attrs,
        dir: state.context.dir,
        "data-state": itemState.isSelected ? "checked" : "unchecked",
        hidden: !itemState.isSelected
      });
    },
    getItemGroupLabelProps(props) {
      const { htmlFor } = props;
      return normalize.element({
        ...parts.itemGroupLabel.attrs,
        id: dom.getItemGroupId(state.context, htmlFor),
        role: "group",
        dir: state.context.dir
      });
    },
    getItemGroupProps(props) {
      const { id } = props;
      return normalize.element({
        ...parts.itemGroup.attrs,
        "data-disabled": dataAttr(isDisabled),
        id: dom.getItemGroupId(state.context, id),
        "aria-labelledby": dom.getItemGroupLabelId(state.context, id),
        dir: state.context.dir
      });
    },
    clearTriggerProps: normalize.button({
      ...parts.clearTrigger.attrs,
      id: dom.getClearTriggerId(state.context),
      type: "button",
      "aria-label": "Clear value",
      disabled: isDisabled,
      hidden: !state.context.hasSelectedItems,
      dir: state.context.dir,
      onClick() {
        send("VALUE.CLEAR");
      }
    }),
    hiddenSelectProps: normalize.select({
      name: state.context.name,
      form: state.context.form,
      disabled: !isInteractive,
      multiple: state.context.multiple,
      "aria-hidden": true,
      id: dom.getHiddenSelectId(state.context),
      // defaultValue: state.context.selectedOption?.value,
      style: visuallyHiddenStyle,
      tabIndex: -1,
      // Some browser extensions will focus the hidden select.
      // Let's forward the focus to the trigger.
      onFocus() {
        dom.getTriggerEl(state.context)?.focus({ preventScroll: true });
      },
      "aria-labelledby": dom.getLabelId(state.context)
    }),
    positionerProps: normalize.element({
      ...parts.positioner.attrs,
      dir: state.context.dir,
      id: dom.getPositionerId(state.context),
      style: popperStyles.floating
    }),
    contentProps: normalize.element({
      hidden: !isOpen,
      dir: state.context.dir,
      id: dom.getContentId(state.context),
      role: "listbox",
      ...parts.content.attrs,
      "data-state": isOpen ? "open" : "closed",
      "aria-activedescendant": state.context.highlightedValue || "",
      "aria-multiselectable": state.context.multiple ? "true" : void 0,
      "aria-labelledby": dom.getLabelId(state.context),
      tabIndex: 0,
      onKeyDown(event) {
        if (!isInteractive || !isSelfEvent(event))
          return;
        const keyMap = {
          ArrowUp() {
            send({ type: "CONTENT.ARROW_UP" });
          },
          ArrowDown() {
            send({ type: "CONTENT.ARROW_DOWN" });
          },
          Home() {
            send({ type: "CONTENT.HOME" });
          },
          End() {
            send({ type: "CONTENT.END" });
          },
          Enter() {
            send({ type: "CONTENT.ENTER" });
          },
          Space(event2) {
            if (isTypingAhead) {
              send({ type: "CONTENT.TYPEAHEAD", key: event2.key });
            } else {
              keyMap.Enter?.(event2);
            }
          }
        };
        const exec = keyMap[getEventKey(event)];
        if (exec) {
          exec(event);
          event.preventDefault();
          return;
        }
        if (isEditableElement(event.target)) {
          return;
        }
        if (getByTypeahead.isValidEvent(event)) {
          send({ type: "CONTENT.TYPEAHEAD", key: event.key });
          event.preventDefault();
        }
      }
    })
  };
}

// src/select.machine.ts
import { createMachine, guards } from "@zag-js/core";
import { trackDismissableElement } from "@zag-js/dismissable";
import { getByTypeahead as getByTypeahead2, raf } from "@zag-js/dom-query";
import { setElementValue, trackFormControl } from "@zag-js/form-utils";
import { observeAttributes } from "@zag-js/mutation-observer";
import { getPlacement } from "@zag-js/popper";
import { proxyTabFocus } from "@zag-js/tabbable";
import { addOrRemove, compact, isEqual } from "@zag-js/utils";
var { and, not } = guards;
function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "select",
      context: {
        value: [],
        highlightedValue: null,
        selectOnBlur: false,
        loop: false,
        closeOnSelect: true,
        disabled: false,
        ...ctx,
        collection: ctx.collection ?? collection.empty(),
        typeahead: getByTypeahead2.defaultOptions,
        fieldsetDisabled: false,
        positioning: {
          placement: "bottom-start",
          gutter: 8,
          ...ctx.positioning
        }
      },
      computed: {
        hasSelectedItems: (ctx2) => ctx2.value.length > 0,
        isTypingAhead: (ctx2) => ctx2.typeahead.keysSoFar !== "",
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        isInteractive: (ctx2) => !(ctx2.isDisabled || ctx2.readOnly),
        selectedItems: (ctx2) => ctx2.collection.items(ctx2.value),
        highlightedItem: (ctx2) => ctx2.collection.item(ctx2.highlightedValue),
        valueAsString: (ctx2) => ctx2.collection.itemsToString(ctx2.selectedItems)
      },
      initial: "idle",
      watch: {
        open: ["toggleVisibility"],
        value: ["syncSelectElement"]
      },
      on: {
        "HIGHLIGHTED_VALUE.SET": {
          actions: ["setHighlightedItem"]
        },
        "ITEM.SELECT": {
          actions: ["selectItem"]
        },
        "ITEM.CLEAR": {
          actions: ["clearItem"]
        },
        "VALUE.SET": {
          actions: ["setSelectedItems"]
        },
        "VALUE.CLEAR": {
          actions: ["clearSelectedItems"]
        },
        "COLLECTION.SET": {
          actions: ["setCollection"]
        },
        "POSITIONING.SET": {
          actions: ["reposition"]
        }
      },
      activities: ["trackFormControlState"],
      states: {
        idle: {
          tags: ["closed"],
          on: {
            "TRIGGER.CLICK": {
              target: "open",
              actions: ["invokeOnOpen", "highlightFirstSelectedItem"]
            },
            "TRIGGER.FOCUS": {
              target: "focused"
            },
            OPEN: {
              target: "open",
              actions: ["invokeOnOpen"]
            }
          }
        },
        focused: {
          tags: ["closed"],
          entry: ["focusTriggerEl"],
          on: {
            OPEN: {
              target: "open",
              actions: ["invokeOnOpen"]
            },
            "TRIGGER.BLUR": {
              target: "idle"
            },
            "TRIGGER.CLICK": {
              target: "open",
              actions: ["invokeOnOpen", "highlightFirstSelectedItem"]
            },
            "TRIGGER.ENTER": [
              {
                guard: "hasSelectedItems",
                target: "open",
                actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["highlightFirstItem", "invokeOnOpen"]
              }
            ],
            "TRIGGER.ARROW_UP": [
              {
                guard: "hasSelectedItems",
                target: "open",
                actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["highlightLastItem", "invokeOnOpen"]
              }
            ],
            "TRIGGER.ARROW_DOWN": [
              {
                guard: "hasSelectedItems",
                target: "open",
                actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["highlightFirstItem", "invokeOnOpen"]
              }
            ],
            "TRIGGER.ARROW_LEFT": [
              {
                guard: and(not("multiple"), "hasSelectedItems"),
                actions: ["selectPreviousItem"]
              },
              {
                guard: not("multiple"),
                actions: ["selectLastItem"]
              }
            ],
            "TRIGGER.ARROW_RIGHT": [
              {
                guard: and(not("multiple"), "hasSelectedItems"),
                actions: ["selectNextItem"]
              },
              {
                guard: not("multiple"),
                actions: ["selectFirstItem"]
              }
            ],
            "TRIGGER.HOME": {
              guard: not("multiple"),
              actions: ["selectFirstItem"]
            },
            "TRIGGER.END": {
              guard: not("multiple"),
              actions: ["selectLastItem"]
            },
            "TRIGGER.TYPEAHEAD": {
              guard: not("multiple"),
              actions: ["selectMatchingItem"]
            }
          }
        },
        open: {
          tags: ["open"],
          entry: ["focusContentEl"],
          exit: ["scrollContentToTop"],
          activities: ["trackDismissableElement", "computePlacement", "scrollToHighlightedItem", "proxyTabFocus"],
          on: {
            CLOSE: {
              target: "focused",
              actions: ["clearHighlightedItem", "invokeOnClose"]
            },
            "TRIGGER.CLICK": {
              target: "focused",
              actions: ["clearHighlightedItem", "invokeOnClose"]
            },
            "ITEM.CLICK": [
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["selectHighlightedItem", "clearHighlightedItem", "invokeOnClose"]
              },
              {
                guard: "multiple",
                actions: ["selectHighlightedItem"]
              },
              {
                actions: ["selectHighlightedItem", "clearHighlightedItem"]
              }
            ],
            "CONTENT.ENTER": [
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["selectHighlightedItem", "clearHighlightedItem", "invokeOnClose"]
              },
              {
                guard: "multiple",
                actions: ["selectHighlightedItem"]
              },
              {
                actions: ["selectHighlightedItem", "clearHighlightedItem"]
              }
            ],
            "CONTENT.INTERACT_OUTSIDE": [
              {
                guard: and("selectOnBlur", "hasHighlightedItem"),
                target: "idle",
                actions: ["selectHighlightedItem", "invokeOnClose", "clearHighlightedItem"]
              },
              {
                guard: "isTargetFocusable",
                target: "idle",
                actions: ["clearHighlightedItem", "invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["clearHighlightedItem", "invokeOnClose"]
              }
            ],
            "CONTENT.HOME": {
              actions: ["highlightFirstItem"]
            },
            "CONTENT.END": {
              actions: ["highlightLastItem"]
            },
            "CONTENT.ARROW_DOWN": [
              {
                guard: and("hasHighlightedItem", "loop", "isLastItemHighlighted"),
                actions: ["highlightFirstItem"]
              },
              {
                guard: "hasHighlightedItem",
                actions: ["highlightNextItem"]
              },
              {
                actions: ["highlightFirstItem"]
              }
            ],
            "CONTENT.ARROW_UP": [
              {
                guard: and("hasHighlightedItem", "loop", "isFirstItemHighlighted"),
                actions: ["highlightLastItem"]
              },
              {
                guard: "hasHighlightedItem",
                actions: ["highlightPreviousItem"]
              },
              {
                actions: ["highlightLastItem"]
              }
            ],
            "CONTENT.TYPEAHEAD": {
              actions: ["highlightMatchingItem"]
            },
            "ITEM.POINTER_MOVE": {
              actions: ["highlightItem"]
            },
            "ITEM.POINTER_LEAVE": {
              actions: ["clearHighlightedItem"]
            }
          }
        }
      }
    },
    {
      guards: {
        loop: (ctx2) => !!ctx2.loop,
        multiple: (ctx2) => !!ctx2.multiple,
        hasSelectedItems: (ctx2) => ctx2.hasSelectedItems,
        hasHighlightedItem: (ctx2) => ctx2.highlightedValue != null,
        isFirstItemHighlighted: (ctx2) => ctx2.highlightedValue === ctx2.collection.first(),
        isLastItemHighlighted: (ctx2) => ctx2.highlightedValue === ctx2.collection.last(),
        selectOnBlur: (ctx2) => !!ctx2.selectOnBlur,
        closeOnSelect: (ctx2, evt) => {
          if (ctx2.multiple)
            return false;
          return !!(evt.closeOnSelect ?? ctx2.closeOnSelect);
        },
        isTargetFocusable: (_ctx, evt) => !!evt.focusable
      },
      activities: {
        proxyTabFocus(ctx2) {
          const contentEl = () => dom.getContentEl(ctx2);
          return proxyTabFocus(contentEl, {
            defer: true,
            triggerElement: dom.getTriggerEl(ctx2),
            onFocus(el) {
              raf(() => el.focus({ preventScroll: true }));
            }
          });
        },
        trackFormControlState(ctx2, _evt, { initialContext }) {
          return trackFormControl(dom.getHiddenSelectEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              set.selectedItems(ctx2, initialContext.value);
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          let focusable = false;
          const contentEl = () => dom.getContentEl(ctx2);
          return trackDismissableElement(contentEl, {
            defer: true,
            exclude: [dom.getTriggerEl(ctx2), dom.getClearTriggerEl(ctx2)],
            onFocusOutside: ctx2.onFocusOutside,
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onInteractOutside(event) {
              focusable = event.detail.focusable;
              ctx2.onInteractOutside?.(event);
            },
            onDismiss() {
              send({ type: "CONTENT.INTERACT_OUTSIDE", focusable });
            }
          });
        },
        computePlacement(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const triggerEl = () => dom.getTriggerEl(ctx2);
          const positionerEl = () => dom.getPositionerEl(ctx2);
          return getPlacement(triggerEl, positionerEl, {
            defer: true,
            ...ctx2.positioning,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        scrollToHighlightedItem(ctx2, _evt, { getState }) {
          const exec = () => {
            const state = getState();
            if (state.event.type.startsWith("ITEM.POINTER"))
              return;
            const optionEl = dom.getHighlightedOptionEl(ctx2);
            optionEl?.scrollIntoView({ block: "nearest" });
          };
          raf(() => exec());
          return observeAttributes(dom.getContentEl(ctx2), ["aria-activedescendant"], exec);
        }
      },
      actions: {
        reposition(ctx2, evt) {
          const positionerEl = () => dom.getPositionerEl(ctx2);
          getPlacement(dom.getTriggerEl(ctx2), positionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        toggleVisibility(ctx2, _evt, { send }) {
          send({ type: ctx2.open ? "OPEN" : "CLOSE", src: "controlled" });
        },
        highlightPreviousItem(ctx2) {
          if (ctx2.highlightedValue == null)
            return;
          const value = ctx2.collection.prev(ctx2.highlightedValue);
          set.highlightedItem(ctx2, value);
        },
        highlightNextItem(ctx2) {
          if (ctx2.highlightedValue == null)
            return;
          const value = ctx2.collection.next(ctx2.highlightedValue);
          set.highlightedItem(ctx2, value);
        },
        highlightFirstItem(ctx2) {
          const value = ctx2.collection.first();
          set.highlightedItem(ctx2, value);
        },
        highlightLastItem(ctx2) {
          const value = ctx2.collection.last();
          set.highlightedItem(ctx2, value);
        },
        focusContentEl(ctx2) {
          raf(() => {
            dom.getContentEl(ctx2)?.focus({ preventScroll: true });
          });
        },
        focusTriggerEl(ctx2) {
          raf(() => {
            dom.getTriggerEl(ctx2)?.focus({ preventScroll: true });
          });
        },
        selectHighlightedItem(ctx2, evt) {
          const value = evt.value ?? ctx2.highlightedValue;
          if (value == null)
            return;
          set.selectedItem(ctx2, value);
        },
        highlightFirstSelectedItem(ctx2) {
          if (!ctx2.hasSelectedItems)
            return;
          const [value] = ctx2.collection.sort(ctx2.value);
          set.highlightedItem(ctx2, value);
        },
        highlightItem(ctx2, evt) {
          set.highlightedItem(ctx2, evt.value);
        },
        highlightMatchingItem(ctx2, evt) {
          const value = ctx2.collection.search(evt.key, {
            state: ctx2.typeahead,
            currentValue: ctx2.highlightedValue
          });
          if (value == null)
            return;
          set.highlightedItem(ctx2, value);
        },
        setHighlightedItem(ctx2, evt) {
          set.highlightedItem(ctx2, evt.value);
        },
        clearHighlightedItem(ctx2) {
          set.highlightedItem(ctx2, null, true);
        },
        selectItem(ctx2, evt) {
          set.selectedItem(ctx2, evt.value);
        },
        clearItem(ctx2, evt) {
          const value = ctx2.value.filter((v) => v !== evt.value);
          set.selectedItems(ctx2, value);
        },
        setSelectedItems(ctx2, evt) {
          set.selectedItems(ctx2, evt.value);
        },
        clearSelectedItems(ctx2) {
          set.selectedItems(ctx2, []);
        },
        selectPreviousItem(ctx2) {
          const value = ctx2.collection.prev(ctx2.value[0]);
          set.selectedItem(ctx2, value);
        },
        selectNextItem(ctx2) {
          const value = ctx2.collection.next(ctx2.value[0]);
          set.selectedItem(ctx2, value);
        },
        selectFirstItem(ctx2) {
          const value = ctx2.collection.first();
          set.selectedItem(ctx2, value);
        },
        selectLastItem(ctx2) {
          const value = ctx2.collection.last();
          set.selectedItem(ctx2, value);
        },
        selectMatchingItem(ctx2, evt) {
          const value = ctx2.collection.search(evt.key, {
            state: ctx2.typeahead,
            currentValue: ctx2.value[0]
          });
          if (value == null)
            return;
          set.selectedItem(ctx2, value);
        },
        scrollContentToTop(ctx2) {
          dom.getContentEl(ctx2)?.scrollTo(0, 0);
        },
        invokeOnOpen(ctx2) {
          ctx2.onOpenChange?.({ open: true });
        },
        invokeOnClose(ctx2) {
          ctx2.onOpenChange?.({ open: false });
        },
        syncSelectElement(ctx2) {
          const selectEl = dom.getHiddenSelectEl(ctx2);
          if (!selectEl)
            return;
          setElementValue(selectEl, ctx2.value.join(","), { type: "HTMLSelectElement" });
        },
        setCollection(ctx2, evt) {
          ctx2.collection = evt.value;
        }
      }
    }
  );
}
function dispatchChangeEvent(ctx) {
  const node = dom.getHiddenSelectEl(ctx);
  if (!node)
    return;
  const win = dom.getWin(ctx);
  const changeEvent = new win.Event("change", { bubbles: true });
  node.dispatchEvent(changeEvent);
}
var invoke = {
  change: (ctx) => {
    ctx.onValueChange?.({
      value: Array.from(ctx.value),
      items: ctx.selectedItems
    });
    dispatchChangeEvent(ctx);
  },
  highlightChange: (ctx) => {
    ctx.onHighlightChange?.({
      highlightedValue: ctx.highlightedValue,
      highlightedItem: ctx.highlightedItem
    });
  }
};
var set = {
  selectedItem: (ctx, value, force = false) => {
    if (isEqual(ctx.value, value))
      return;
    if (value == null && !force)
      return;
    if (value == null && force) {
      ctx.value = [];
      invoke.change(ctx);
      return;
    }
    const nextValue = ctx.multiple ? addOrRemove(ctx.value, value) : [value];
    ctx.value = nextValue;
    invoke.change(ctx);
  },
  selectedItems: (ctx, value) => {
    if (isEqual(ctx.value, value))
      return;
    ctx.value = value;
    invoke.change(ctx);
  },
  highlightedItem: (ctx, value, force = false) => {
    if (isEqual(ctx.highlightedValue, value))
      return;
    if (value == null && !force)
      return;
    ctx.highlightedValue = value ?? null;
    invoke.highlightChange(ctx);
  }
};
export {
  anatomy,
  collection,
  connect,
  machine
};
//# sourceMappingURL=index.mjs.map