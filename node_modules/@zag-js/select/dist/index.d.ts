import * as _zag_js_anatomy from '@zag-js/anatomy';
import { CollectionOptions, Collection, CollectionItem } from '@zag-js/collection';
export { CollectionItem, CollectionOptions } from '@zag-js/collection';
import { RequiredBy, PropTypes, DirectionProperty, CommonProperties, Context, NormalizeProps } from '@zag-js/types';
import * as _zag_js_core from '@zag-js/core';
import { StateMachine } from '@zag-js/core';
import { InteractOutsideHandlers } from '@zag-js/dismissable';
import { PositioningOptions } from '@zag-js/popper';

declare const anatomy: _zag_js_anatomy.AnatomyInstance<"label" | "positioner" | "trigger" | "indicator" | "clearTrigger" | "item" | "itemText" | "itemIndicator" | "itemGroup" | "itemGroupLabel" | "content" | "root" | "control">;

declare const collection: {
    <T extends unknown>(options: CollectionOptions<T>): Collection<T>;
    empty(): Collection<CollectionItem>;
};

interface ValueChangeDetails<T extends CollectionItem = CollectionItem> {
    value: string[];
    items: T[];
}
interface HighlightChangeDetails<T extends CollectionItem = CollectionItem> {
    highlightedValue: string | null;
    highlightedItem: T | null;
}
interface OpenChangeDetails {
    open: boolean;
}
type ElementIds = Partial<{
    root: string;
    content: string;
    control: string;
    trigger: string;
    clearTrigger: string;
    label: string;
    hiddenSelect: string;
    positioner: string;
    item(id: string | number): string;
    itemGroup(id: string | number): string;
    itemGroupLabel(id: string | number): string;
}>;
interface PublicContext<T extends CollectionItem = CollectionItem> extends DirectionProperty, CommonProperties, InteractOutsideHandlers {
    /**
     * The item collection
     */
    collection: Collection<CollectionItem>;
    /**
     * The ids of the elements in the select. Useful for composition.
     */
    ids?: ElementIds;
    /**
     * The `name` attribute of the underlying select.
     */
    name?: string;
    /**
     * The associate form of the underlying select.
     */
    form?: string;
    /**
     * Whether the select is disabled
     */
    disabled?: boolean;
    /**
     * Whether the select is invalid
     */
    invalid?: boolean;
    /**
     * Whether the select is read-only
     */
    readOnly?: boolean;
    /**
     * Whether the select should close after an item is selected
     */
    closeOnSelect?: boolean;
    /**
     * Whether to select the highlighted item when the user presses Tab,
     * and the menu is open.
     */
    selectOnBlur?: boolean;
    /**
     * The callback fired when the highlighted item changes.
     */
    onHighlightChange?: (details: HighlightChangeDetails<T>) => void;
    /**
     * The callback fired when the selected item changes.
     */
    onValueChange?: (details: ValueChangeDetails<T>) => void;
    /**
     * Function called when the popup is opened
     */
    onOpenChange?: (details: OpenChangeDetails) => void;
    /**
     * The positioning options of the menu.
     */
    positioning: PositioningOptions;
    /**
     * The keys of the selected items
     */
    value: string[];
    /**
     * The key of the highlighted item
     */
    highlightedValue: string | null;
    /**
     * Whether to loop the keyboard navigation through the options
     */
    loop?: boolean;
    /**
     * Whether to allow multiple selection
     */
    multiple?: boolean;
    /**
     * Whether the select menu is open
     */
    open?: boolean;
}
type PrivateContext = Context<{}>;
type ComputedContext<T extends CollectionItem = CollectionItem> = Readonly<{
    /**
     * @computed
     * Whether there's a selected option
     */
    hasSelectedItems: boolean;
    /**
     * @computed
     * Whether a typeahead is currently active
     */
    isTypingAhead: boolean;
    /**
     * @computed
     * Whether the select is interactive
     */
    isInteractive: boolean;
    /**
     * @computed
     * Whether the select is disabled
     */
    isDisabled: boolean;
    /**
     * The highlighted item
     */
    highlightedItem: T | null;
    /**
     * @computed
     * The selected items
     */
    selectedItems: T[];
    /**
     * @computed
     * The display value of the select (based on the selected items)
     */
    valueAsString: string;
}>;
type UserDefinedContext<T extends CollectionItem = CollectionItem> = RequiredBy<PublicContext<T>, "id" | "collection">;
interface MachineContext extends PublicContext, PrivateContext, ComputedContext {
}
interface MachineState {
    value: "idle" | "focused" | "open";
}
type State = StateMachine.State<MachineContext, MachineState>;
type Send = StateMachine.Send<StateMachine.AnyEventObject>;
interface ItemProps<T extends CollectionItem = CollectionItem> {
    item: T;
}
interface ItemState {
    value: string;
    isDisabled: boolean;
    isSelected: boolean;
    isHighlighted: boolean;
}
interface ItemGroupProps {
    id: string;
}
interface ItemGroupLabelProps {
    htmlFor: string;
}
interface MachineApi<T extends PropTypes = PropTypes, V extends CollectionItem = CollectionItem> {
    /**
     * Whether the select is focused
     */
    isFocused: boolean;
    /**
     * Whether the select is open
     */
    isOpen: boolean;
    /**
     * The value of the highlighted item
     */
    highlightedValue: string | null;
    /**
     * The highlighted item
     */
    highlightedItem: V | null;
    /**
     * The value of the combobox input
     */
    highlightValue(value: string): void;
    /**
     * The selected items
     */
    selectedItems: V[];
    /**
     * Whether there's a selected option
     */
    hasSelectedItems: boolean;
    /**
     * The selected item keys
     */
    value: string[];
    /**
     * The string representation of the selected items
     */
    valueAsString: string;
    /**
     * Function to select a value
     */
    selectValue(value: string): void;
    /**
     * Function to set the value of the combobox
     */
    setValue(value: string[]): void;
    /**
     * Function to clear the value of the combobox
     */
    clearValue(value?: string): void;
    /**
     * Function to focus on the combobox input
     */
    focus(): void;
    /**
     * Returns the state of a combobox item
     */
    getItemState(props: ItemProps): ItemState;
    /**
     * Function to open the combobox
     */
    open(): void;
    /**
     * Function to close the combobox
     */
    close(): void;
    /**
     * Function to toggle the combobox
     */
    collection: Collection<V>;
    /**
     * Function to set the collection of items
     */
    setCollection(collection: Collection<V>): void;
    /**
     * Function to set the positioning options of the select
     */
    reposition(options: Partial<PositioningOptions>): void;
    rootProps: T["element"];
    labelProps: T["label"];
    controlProps: T["element"];
    triggerProps: T["button"];
    indicatorProps: T["element"];
    clearTriggerProps: T["button"];
    positionerProps: T["element"];
    contentProps: T["element"];
    getItemProps(props: ItemProps): T["element"];
    getItemTextProps(props: ItemProps): T["element"];
    getItemIndicatorProps(props: ItemProps): T["element"];
    getItemGroupProps(props: ItemGroupProps): T["element"];
    getItemGroupLabelProps(props: ItemGroupLabelProps): T["element"];
    hiddenSelectProps: T["select"];
}

declare function connect<T extends PropTypes, V extends CollectionItem = CollectionItem>(state: State, send: Send, normalize: NormalizeProps<T>): MachineApi<T, V>;

declare function machine<T extends CollectionItem>(userContext: UserDefinedContext<T>): _zag_js_core.Machine<MachineContext, MachineState, _zag_js_core.StateMachine.AnyEventObject>;

export { type MachineApi as Api, type UserDefinedContext as Context, type ElementIds, type HighlightChangeDetails, type ItemGroupLabelProps, type ItemGroupProps, type ItemProps, type ItemState, type OpenChangeDetails, type ValueChangeDetails, anatomy, collection, connect, machine };
