// src/tabs.anatomy.ts
import { createAnatomy } from "@zag-js/anatomy";
var anatomy = createAnatomy("tabs").parts("root", "list", "trigger", "content", "indicator");
var parts = anatomy.build();

// src/tabs.connect.ts
import { getEventKey } from "@zag-js/dom-event";
import { dataAttr, isSafari, isSelfEvent } from "@zag-js/dom-query";

// src/tabs.dom.ts
import { createScope, itemById, nextById, prevById, queryAll } from "@zag-js/dom-query";
import { first, last } from "@zag-js/utils";
var dom = createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `tabs:${ctx.id}`,
  getTablistId: (ctx) => ctx.ids?.tablist ?? `tabs:${ctx.id}:list`,
  getContentId: (ctx, id) => ctx.ids?.content ?? `tabs:${ctx.id}:content-${id}`,
  getTriggerId: (ctx, id) => ctx.ids?.trigger ?? `tabs:${ctx.id}:trigger-${id}`,
  getIndicatorId: (ctx) => ctx.ids?.indicator ?? `tabs:${ctx.id}:indicator`,
  getTablistEl: (ctx) => dom.getById(ctx, dom.getTablistId(ctx)),
  getContentEl: (ctx, id) => dom.getById(ctx, dom.getContentId(ctx, id)),
  getTriggerEl: (ctx, id) => dom.getById(ctx, dom.getTriggerId(ctx, id)),
  getIndicatorEl: (ctx) => dom.getById(ctx, dom.getIndicatorId(ctx)),
  getElements: (ctx) => {
    const ownerId = CSS.escape(dom.getTablistId(ctx));
    const selector = `[role=tab][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(dom.getTablistEl(ctx), selector);
  },
  getFirstEl: (ctx) => first(dom.getElements(ctx)),
  getLastEl: (ctx) => last(dom.getElements(ctx)),
  getNextEl: (ctx, id) => nextById(dom.getElements(ctx), dom.getTriggerId(ctx, id), ctx.loop),
  getPrevEl: (ctx, id) => prevById(dom.getElements(ctx), dom.getTriggerId(ctx, id), ctx.loop),
  getActiveContentEl: (ctx) => {
    if (!ctx.value)
      return;
    return dom.getContentEl(ctx, ctx.value);
  },
  getActiveTabEl: (ctx) => {
    if (!ctx.value)
      return;
    return dom.getTriggerEl(ctx, ctx.value);
  },
  getOffsetRect: (el) => {
    return {
      left: el?.offsetLeft ?? 0,
      top: el?.offsetTop ?? 0,
      width: el?.offsetWidth ?? 0,
      height: el?.offsetHeight ?? 0
    };
  },
  getRectById: (ctx, id) => {
    const tab = itemById(dom.getElements(ctx), dom.getTriggerId(ctx, id));
    return dom.resolveRect(dom.getOffsetRect(tab));
  },
  resolveRect: (rect) => ({
    width: `${rect.width}px`,
    height: `${rect.height}px`,
    left: `${rect.left}px`,
    top: `${rect.top}px`
  })
});

// src/tabs.connect.ts
function connect(state, send, normalize) {
  const translations = state.context.translations;
  const isFocused = state.matches("focused");
  function getTriggerState(props) {
    return {
      isSelected: state.context.value === props.value,
      isFocused: state.context.focusedValue === props.value,
      isDisabled: !!props.disabled
    };
  }
  return {
    value: state.context.value,
    focusedValue: state.context.focusedValue,
    previousValues: Array.from(state.context.previousValues),
    setValue(value) {
      send({ type: "SET_VALUE", value });
    },
    clearValue() {
      send({ type: "CLEAR_VALUE" });
    },
    setIndicatorRect(value) {
      const id = dom.getTriggerId(state.context, value);
      send({ type: "SET_INDICATOR_RECT", id });
    },
    getTriggerState,
    rootProps: normalize.element({
      ...parts.root.attrs,
      id: dom.getRootId(state.context),
      "data-orientation": state.context.orientation,
      "data-focus": dataAttr(isFocused),
      dir: state.context.dir
    }),
    tablistProps: normalize.element({
      ...parts.list.attrs,
      id: dom.getTablistId(state.context),
      role: "tablist",
      dir: state.context.dir,
      "data-focus": dataAttr(isFocused),
      "aria-orientation": state.context.orientation,
      "data-orientation": state.context.orientation,
      "aria-label": translations.tablistLabel,
      onKeyDown(event) {
        if (!isSelfEvent(event))
          return;
        const keyMap = {
          ArrowDown() {
            send("ARROW_DOWN");
          },
          ArrowUp() {
            send("ARROW_UP");
          },
          ArrowLeft() {
            send("ARROW_LEFT");
          },
          ArrowRight() {
            send("ARROW_RIGHT");
          },
          Home() {
            send("HOME");
          },
          End() {
            send("END");
          },
          Enter() {
            send({ type: "ENTER", value: state.context.focusedValue });
          }
        };
        let key = getEventKey(event, state.context);
        const exec = keyMap[key];
        if (exec) {
          event.preventDefault();
          exec(event);
        }
      }
    }),
    getTriggerProps(props) {
      const { value, disabled } = props;
      const triggerState = getTriggerState(props);
      return normalize.button({
        ...parts.trigger.attrs,
        role: "tab",
        type: "button",
        disabled,
        dir: state.context.dir,
        "data-orientation": state.context.orientation,
        "data-disabled": dataAttr(disabled),
        "aria-disabled": disabled,
        "data-value": value,
        "aria-selected": triggerState.isSelected,
        "data-selected": dataAttr(triggerState.isSelected),
        "data-focus": dataAttr(triggerState.isFocused),
        "aria-controls": dom.getContentId(state.context, value),
        "data-ownedby": dom.getTablistId(state.context),
        id: dom.getTriggerId(state.context, value),
        tabIndex: triggerState.isSelected ? 0 : -1,
        onFocus() {
          send({ type: "TAB_FOCUS", value });
        },
        onBlur(event) {
          const target = event.relatedTarget;
          if (target?.getAttribute("role") !== "tab") {
            send({ type: "TAB_BLUR" });
          }
        },
        onClick(event) {
          if (disabled)
            return;
          if (isSafari()) {
            event.currentTarget.focus();
          }
          send({ type: "TAB_CLICK", value });
        }
      });
    },
    getContentProps(props) {
      const { value } = props;
      const selected = state.context.value === value;
      return normalize.element({
        ...parts.content.attrs,
        dir: state.context.dir,
        id: dom.getContentId(state.context, value),
        tabIndex: 0,
        "aria-labelledby": dom.getTriggerId(state.context, value),
        role: "tabpanel",
        "data-ownedby": dom.getTablistId(state.context),
        "data-selected": dataAttr(selected),
        "data-orientation": state.context.orientation,
        hidden: !selected
      });
    },
    indicatorProps: normalize.element({
      id: dom.getIndicatorId(state.context),
      ...parts.indicator.attrs,
      dir: state.context.dir,
      "data-orientation": state.context.orientation,
      style: {
        "--transition-duration": "150ms",
        "--transition-property": "left, right, top, bottom, width, height",
        "--left": state.context.indicatorRect?.left,
        "--top": state.context.indicatorRect?.top,
        "--width": state.context.indicatorRect?.width,
        "--height": state.context.indicatorRect?.height,
        position: "absolute",
        willChange: "var(--transition-property)",
        transitionProperty: "var(--transition-property)",
        transitionDuration: state.context.canIndicatorTransition ? "var(--transition-duration)" : "0ms",
        transitionTimingFunction: "var(--transition-timing-function)",
        [state.context.orientation === "horizontal" ? "left" : "top"]: state.context.orientation === "horizontal" ? "var(--left)" : "var(--top)"
      }
    })
  };
}

// src/tabs.machine.ts
import { createMachine, guards } from "@zag-js/core";
import { nextTick, raf } from "@zag-js/dom-query";
import { trackElementRect } from "@zag-js/element-rect";
import { getFocusables } from "@zag-js/tabbable";
import { compact, isEqual } from "@zag-js/utils";
var { not } = guards;
function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      initial: "idle",
      context: {
        dir: "ltr",
        orientation: "horizontal",
        activationMode: "automatic",
        value: null,
        focusedValue: null,
        previousValues: [],
        indicatorRect: {
          left: "0px",
          top: "0px",
          width: "0px",
          height: "0px"
        },
        canIndicatorTransition: false,
        isIndicatorRendered: false,
        loop: true,
        translations: {},
        ...ctx
      },
      computed: {
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal",
        isVertical: (ctx2) => ctx2.orientation === "vertical"
      },
      created: ["setPrevSelectedTabs"],
      entry: ["checkRenderedElements", "syncIndicatorRect", "setContentTabIndex"],
      exit: ["cleanupObserver"],
      watch: {
        value: ["enableIndicatorTransition", "setPrevSelectedTabs", "syncIndicatorRect", "setContentTabIndex"],
        dir: ["syncIndicatorRect"],
        orientation: ["syncIndicatorRect"]
      },
      on: {
        SET_VALUE: {
          actions: "setValue"
        },
        CLEAR_VALUE: {
          actions: "clearValue"
        },
        SET_INDICATOR_RECT: {
          actions: "setIndicatorRect"
        }
      },
      states: {
        idle: {
          on: {
            TAB_FOCUS: [
              {
                guard: "selectOnFocus",
                target: "focused",
                actions: ["setFocusedValue", "setValue"]
              },
              {
                target: "focused",
                actions: "setFocusedValue"
              }
            ],
            TAB_CLICK: {
              target: "focused",
              actions: ["setFocusedValue", "setValue"]
            }
          }
        },
        focused: {
          on: {
            TAB_CLICK: {
              target: "focused",
              actions: ["setFocusedValue", "setValue"]
            },
            ARROW_LEFT: {
              guard: "isHorizontal",
              actions: "focusPrevTab"
            },
            ARROW_RIGHT: {
              guard: "isHorizontal",
              actions: "focusNextTab"
            },
            ARROW_UP: {
              guard: "isVertical",
              actions: "focusPrevTab"
            },
            ARROW_DOWN: {
              guard: "isVertical",
              actions: "focusNextTab"
            },
            HOME: {
              actions: "focusFirstTab"
            },
            END: {
              actions: "focusLastTab"
            },
            ENTER: {
              guard: not("selectOnFocus"),
              actions: "setValue"
            },
            TAB_FOCUS: [
              {
                guard: "selectOnFocus",
                actions: ["setFocusedValue", "setValue"]
              },
              { actions: "setFocusedValue" }
            ],
            TAB_BLUR: {
              target: "idle",
              actions: "clearFocusedValue"
            }
          }
        }
      }
    },
    {
      guards: {
        isVertical: (ctx2) => ctx2.isVertical,
        isHorizontal: (ctx2) => ctx2.isHorizontal,
        selectOnFocus: (ctx2) => ctx2.activationMode === "automatic"
      },
      actions: {
        setFocusedValue(ctx2, evt) {
          set.focusedValue(ctx2, evt.value);
        },
        clearFocusedValue(ctx2) {
          set.focusedValue(ctx2, null);
        },
        setValue(ctx2, evt) {
          set.value(ctx2, evt.value);
        },
        clearValue(ctx2) {
          set.value(ctx2, null);
        },
        focusFirstTab(ctx2) {
          raf(() => dom.getFirstEl(ctx2)?.focus());
        },
        focusLastTab(ctx2) {
          raf(() => dom.getLastEl(ctx2)?.focus());
        },
        focusNextTab(ctx2) {
          if (!ctx2.focusedValue)
            return;
          const next = dom.getNextEl(ctx2, ctx2.focusedValue);
          raf(() => next?.focus());
        },
        focusPrevTab(ctx2) {
          if (!ctx2.focusedValue)
            return;
          const prev = dom.getPrevEl(ctx2, ctx2.focusedValue);
          raf(() => prev?.focus());
        },
        checkRenderedElements(ctx2) {
          ctx2.isIndicatorRendered = !!dom.getIndicatorEl(ctx2);
        },
        setPrevSelectedTabs(ctx2) {
          if (ctx2.value != null) {
            ctx2.previousValues = pushUnique(ctx2.previousValues, ctx2.value);
          }
        },
        // if tab panel contains focusable elements, remove the tabindex attribute
        setContentTabIndex(ctx2) {
          raf(() => {
            const panel = dom.getActiveContentEl(ctx2);
            if (!panel)
              return;
            const focusables = getFocusables(panel);
            if (focusables.length > 0) {
              panel.removeAttribute("tabindex");
            } else {
              panel.setAttribute("tabindex", "0");
            }
          });
        },
        cleanupObserver(ctx2) {
          ctx2.indicatorCleanup?.();
        },
        enableIndicatorTransition(ctx2) {
          ctx2.canIndicatorTransition = true;
        },
        setIndicatorRect(ctx2, evt) {
          const value = evt.id ?? ctx2.value;
          if (!ctx2.isIndicatorRendered || !value)
            return;
          const tabEl = dom.getTriggerEl(ctx2, value);
          if (!tabEl)
            return;
          ctx2.indicatorRect = dom.getRectById(ctx2, value);
          nextTick(() => {
            ctx2.canIndicatorTransition = false;
          });
        },
        syncIndicatorRect(ctx2) {
          ctx2.indicatorCleanup?.();
          const value = ctx2.value;
          if (!ctx2.isIndicatorRendered || !value)
            return;
          const tabEl = dom.getActiveTabEl(ctx2);
          if (!tabEl)
            return;
          ctx2.indicatorCleanup = trackElementRect(tabEl, {
            getRect(el) {
              return dom.getOffsetRect(el);
            },
            onChange(rect) {
              ctx2.indicatorRect = dom.resolveRect(rect);
              nextTick(() => {
                ctx2.canIndicatorTransition = false;
              });
            }
          });
        }
      }
    }
  );
}
function pushUnique(arr, value) {
  const newArr = Array.from(arr).slice();
  const index = newArr.indexOf(value);
  if (index > -1) {
    newArr.splice(index, 1);
  }
  newArr.push(value);
  return newArr;
}
var invoke = {
  change: (ctx) => {
    if (ctx.value == null)
      return;
    ctx.onValueChange?.({ value: ctx.value });
  },
  focusChange: (ctx) => {
    if (ctx.focusedValue == null)
      return;
    ctx.onFocusChange?.({ focusedValue: ctx.focusedValue });
  }
};
var set = {
  value: (ctx, value) => {
    if (isEqual(value, ctx.value))
      return;
    ctx.value = value;
    invoke.change(ctx);
  },
  focusedValue: (ctx, value) => {
    if (isEqual(value, ctx.focusedValue))
      return;
    ctx.focusedValue = value;
    invoke.focusChange(ctx);
  }
};
export {
  anatomy,
  connect,
  machine
};
//# sourceMappingURL=index.mjs.map