// src/hover-card.anatomy.ts
import { createAnatomy } from "@zag-js/anatomy";
var anatomy = createAnatomy("hoverCard").parts("arrow", "arrowTip", "trigger", "positioner", "content");
var parts = anatomy.build();

// src/hover-card.connect.ts
import { getPlacementStyles } from "@zag-js/popper";

// src/hover-card.dom.ts
import { createScope } from "@zag-js/dom-query";
var dom = createScope({
  getTriggerId: (ctx) => ctx.ids?.trigger ?? `hover-card:${ctx.id}:trigger`,
  getContentId: (ctx) => ctx.ids?.content ?? `hover-card:${ctx.id}:content`,
  getPositionerId: (ctx) => ctx.ids?.positioner ?? `hover-card:${ctx.id}:popper`,
  getArrowId: (ctx) => ctx.ids?.arrow ?? `hover-card:${ctx.id}:arrow`,
  getTriggerEl: (ctx) => dom.getById(ctx, dom.getTriggerId(ctx)),
  getContentEl: (ctx) => dom.getById(ctx, dom.getContentId(ctx)),
  getPositionerEl: (ctx) => dom.getById(ctx, dom.getPositionerId(ctx))
});

// src/hover-card.connect.ts
function connect(state, send, normalize) {
  const isOpen = state.hasTag("open");
  const popperStyles = getPlacementStyles({
    ...state.context.positioning,
    placement: state.context.currentPlacement
  });
  return {
    isOpen,
    open() {
      send("OPEN");
    },
    close() {
      send("CLOSE");
    },
    reposition(options = {}) {
      send({ type: "SET_POSITIONING", options });
    },
    arrowProps: normalize.element({
      id: dom.getArrowId(state.context),
      ...parts.arrow.attrs,
      dir: state.context.dir,
      style: popperStyles.arrow
    }),
    arrowTipProps: normalize.element({
      ...parts.arrowTip.attrs,
      dir: state.context.dir,
      style: popperStyles.arrowTip
    }),
    triggerProps: normalize.element({
      ...parts.trigger.attrs,
      dir: state.context.dir,
      "data-placement": state.context.currentPlacement,
      id: dom.getTriggerId(state.context),
      "data-state": isOpen ? "open" : "closed",
      onPointerEnter(event) {
        if (event.pointerType === "touch")
          return;
        send({ type: "POINTER_ENTER", src: "trigger" });
      },
      onPointerLeave(event) {
        if (event.pointerType === "touch")
          return;
        send({ type: "POINTER_LEAVE", src: "trigger" });
      },
      onFocus() {
        send("TRIGGER_FOCUS");
      },
      onBlur() {
        send("TRIGGER_BLUR");
      },
      onTouchStart(event) {
        event.preventDefault();
      }
    }),
    positionerProps: normalize.element({
      id: dom.getPositionerId(state.context),
      ...parts.positioner.attrs,
      dir: state.context.dir,
      style: popperStyles.floating
    }),
    contentProps: normalize.element({
      ...parts.content.attrs,
      dir: state.context.dir,
      id: dom.getContentId(state.context),
      hidden: !isOpen,
      "data-state": isOpen ? "open" : "closed",
      "data-placement": state.context.currentPlacement,
      onPointerEnter(event) {
        if (event.pointerType === "touch")
          return;
        send({ type: "POINTER_ENTER", src: "content" });
      },
      onPointerLeave(event) {
        if (event.pointerType === "touch")
          return;
        send({ type: "POINTER_LEAVE", src: "content" });
      }
    })
  };
}

// src/hover-card.machine.ts
import { createMachine, guards } from "@zag-js/core";
import { trackDismissableElement } from "@zag-js/dismissable";
import { getPlacement } from "@zag-js/popper";
import { compact } from "@zag-js/utils";
var { not } = guards;
function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "hover-card",
      initial: ctx.open ? "open" : "closed",
      context: {
        openDelay: 700,
        closeDelay: 300,
        currentPlacement: void 0,
        ...ctx,
        positioning: {
          placement: "bottom",
          ...ctx.positioning
        }
      },
      watch: {
        open: ["toggleVisibility"]
      },
      states: {
        closed: {
          tags: ["closed"],
          entry: ["clearIsPointer"],
          on: {
            POINTER_ENTER: {
              target: "opening",
              actions: ["setIsPointer"]
            },
            TRIGGER_FOCUS: "opening",
            OPEN: "opening"
          }
        },
        opening: {
          tags: ["closed"],
          after: {
            OPEN_DELAY: {
              target: "open",
              actions: ["invokeOnOpen"]
            }
          },
          on: {
            POINTER_LEAVE: {
              target: "closed",
              actions: ["invokeOnClose"]
            },
            TRIGGER_BLUR: {
              guard: not("isPointer"),
              target: "closed",
              actions: ["invokeOnClose"]
            },
            CLOSE: {
              target: "closed",
              actions: ["invokeOnClose"]
            }
          }
        },
        open: {
          tags: ["open"],
          activities: ["trackDismissableElement", "trackPositioning"],
          on: {
            POINTER_ENTER: {
              actions: ["setIsPointer"]
            },
            POINTER_LEAVE: "closing",
            DISMISS: {
              target: "closed",
              actions: ["invokeOnClose"]
            },
            CLOSE: {
              target: "closed",
              actions: ["invokeOnClose"]
            },
            TRIGGER_BLUR: {
              guard: not("isPointer"),
              target: "closed",
              actions: ["invokeOnClose"]
            },
            SET_POSITIONING: {
              actions: "reposition"
            }
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackPositioning"],
          after: {
            CLOSE_DELAY: {
              target: "closed",
              actions: ["invokeOnClose"]
            }
          },
          on: {
            POINTER_ENTER: {
              target: "open",
              // no need to invokeOnOpen here because it's still open (but about to close)
              actions: ["setIsPointer"]
            }
          }
        }
      }
    },
    {
      guards: {
        isPointer: (ctx2) => !!ctx2.isPointer
      },
      activities: {
        trackPositioning(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const getPositionerEl = () => dom.getPositionerEl(ctx2);
          return getPlacement(dom.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            },
            onCleanup() {
              ctx2.currentPlacement = void 0;
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom.getContentEl(ctx2);
          return trackDismissableElement(getContentEl, {
            defer: true,
            exclude: [dom.getTriggerEl(ctx2)],
            onDismiss() {
              send({ type: "DISMISS" });
            },
            onFocusOutside(event) {
              event.preventDefault();
            }
          });
        }
      },
      actions: {
        invokeOnClose(ctx2) {
          ctx2.onOpenChange?.({ open: false });
        },
        invokeOnOpen(ctx2) {
          ctx2.onOpenChange?.({ open: true });
        },
        setIsPointer(ctx2) {
          ctx2.isPointer = true;
        },
        clearIsPointer(ctx2) {
          ctx2.isPointer = false;
        },
        reposition(ctx2, evt) {
          const getPositionerEl = () => dom.getPositionerEl(ctx2);
          getPlacement(dom.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        toggleVisibility(ctx2, _evt, { send }) {
          send({ type: ctx2.open ? "OPEN" : "CLOSE", src: "controlled" });
        }
      },
      delays: {
        OPEN_DELAY: (ctx2) => ctx2.openDelay,
        CLOSE_DELAY: (ctx2) => ctx2.closeDelay
      }
    }
  );
}
export {
  anatomy,
  connect,
  machine
};
//# sourceMappingURL=index.mjs.map