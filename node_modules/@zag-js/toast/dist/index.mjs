// src/toast-group.connect.ts
import { subscribe } from "@zag-js/core";
import { runIfFn, uuid } from "@zag-js/utils";

// src/toast.anatomy.ts
import { createAnatomy } from "@zag-js/anatomy";
var anatomy = createAnatomy("toast").parts("group", "root", "title", "description", "closeTrigger");
var parts = anatomy.build();

// src/toast.dom.ts
import { createScope } from "@zag-js/dom-query";
var dom = createScope({
  getGroupId: (placement) => `toast-group:${placement}`,
  getRootId: (ctx) => `toast:${ctx.id}`,
  getTitleId: (ctx) => `toast:${ctx.id}:title`,
  getDescriptionId: (ctx) => `toast:${ctx.id}:description`,
  getCloseTriggerId: (ctx) => `toast${ctx.id}:close`
});

// src/toast.utils.ts
function getToastsByPlacement(toasts) {
  const result = {};
  for (const toast of toasts) {
    const placement = toast.state.context.placement;
    result[placement] || (result[placement] = []);
    result[placement].push(toast);
  }
  return result;
}
var defaultTimeouts = {
  info: 5e3,
  error: 5e3,
  success: 2e3,
  loading: Infinity,
  custom: 5e3
};
function getToastDuration(duration, type) {
  return duration ?? defaultTimeouts[type];
}
function getGroupPlacementStyle(ctx, placement) {
  const offset = ctx.offsets;
  const computedOffset = typeof offset === "string" ? { left: offset, right: offset, bottom: offset, top: offset } : offset;
  const rtl = ctx.dir === "rtl";
  const computedPlacement = placement.replace("-start", rtl ? "-right" : "-left").replace("-end", rtl ? "-left" : "-right");
  const isRighty = computedPlacement.includes("right");
  const isLefty = computedPlacement.includes("left");
  const styles = {
    position: "fixed",
    pointerEvents: ctx.count > 0 ? void 0 : "none",
    display: "flex",
    flexDirection: "column",
    "--toast-gutter": ctx.gutter,
    zIndex: ctx.zIndex
  };
  let alignItems = "center";
  if (isRighty)
    alignItems = "flex-end";
  if (isLefty)
    alignItems = "flex-start";
  styles.alignItems = alignItems;
  if (computedPlacement.includes("top")) {
    const offset2 = computedOffset.top;
    styles.top = `calc(env(safe-area-inset-top, 0px) + ${offset2})`;
  }
  if (computedPlacement.includes("bottom")) {
    const offset2 = computedOffset.bottom;
    styles.bottom = `calc(env(safe-area-inset-bottom, 0px) + ${offset2})`;
  }
  if (!computedPlacement.includes("left")) {
    const offset2 = computedOffset.right;
    styles.right = `calc(env(safe-area-inset-right, 0px) + ${offset2})`;
  }
  if (!computedPlacement.includes("right")) {
    const offset2 = computedOffset.left;
    styles.left = `calc(env(safe-area-inset-left, 0px) + ${offset2})`;
  }
  return styles;
}

// src/toast-group.connect.ts
function groupConnect(state, send, normalize) {
  const toastsByPlacement = getToastsByPlacement(state.context.toasts);
  function isVisible(id) {
    if (!state.context.toasts.length)
      return false;
    return !!state.context.toasts.find((toast) => toast.id == id);
  }
  function create(options) {
    const uid = `toast:${uuid()}`;
    const id = options.id ? options.id : uid;
    if (isVisible(id))
      return;
    send({ type: "ADD_TOAST", toast: { ...options, id } });
    return id;
  }
  function update(id, options) {
    if (!isVisible(id))
      return;
    send({ type: "UPDATE_TOAST", id, toast: options });
    return id;
  }
  function upsert(options) {
    const { id } = options;
    const visible = id ? isVisible(id) : false;
    if (visible && id != null) {
      return update(id, options);
    } else {
      return create(options);
    }
  }
  function dismiss(id) {
    if (id == null) {
      send("DISMISS_ALL");
    } else if (isVisible(id)) {
      send({ type: "DISMISS_TOAST", id });
    }
  }
  return {
    count: state.context.count,
    toasts: state.context.toasts,
    toastsByPlacement,
    isVisible,
    create,
    update,
    upsert,
    dismiss,
    remove(id) {
      if (id == null) {
        send("REMOVE_ALL");
      } else if (isVisible(id)) {
        send({ type: "REMOVE_TOAST", id });
      }
    },
    dismissByPlacement(placement) {
      const toasts = toastsByPlacement[placement];
      if (toasts) {
        toasts.forEach((toast) => dismiss(toast.id));
      }
    },
    loading(options) {
      return upsert({ ...options, type: "loading" });
    },
    success(options) {
      return upsert({ ...options, type: "success" });
    },
    error(options) {
      return upsert({ ...options, type: "error" });
    },
    promise(promise, options, shared = {}) {
      const id = upsert({ ...shared, ...options.loading, type: "loading" });
      promise.then((response) => {
        const successOptions = runIfFn(options.success, response);
        upsert({ ...shared, ...successOptions, id, type: "success" });
      }).catch((error) => {
        const errorOptions = runIfFn(options.error, error);
        upsert({ ...shared, ...errorOptions, id, type: "error" });
      });
      return promise;
    },
    pause(id) {
      if (id == null) {
        send("PAUSE_ALL");
      } else if (isVisible(id)) {
        send({ type: "PAUSE_TOAST", id });
      }
    },
    resume(id) {
      if (id == null) {
        send("RESUME_ALL");
      } else if (isVisible(id)) {
        send({ type: "RESUME_TOAST", id });
      }
    },
    getGroupProps(options) {
      const { placement, label = "Notifications" } = options;
      return normalize.element({
        ...parts.group.attrs,
        dir: state.context.dir,
        tabIndex: -1,
        "aria-label": `${placement} ${label}`,
        id: dom.getGroupId(placement),
        "data-placement": placement,
        "aria-live": "polite",
        role: "region",
        style: getGroupPlacementStyle(state.context, placement)
      });
    },
    subscribe(fn) {
      return subscribe(state.context.toasts, () => fn(state.context.toasts));
    }
  };
}

// src/toast-group.machine.ts
import { createMachine as createMachine2 } from "@zag-js/core";
import { MAX_Z_INDEX } from "@zag-js/dom-query";
import { compact as compact2 } from "@zag-js/utils";

// src/toast.machine.ts
import { createMachine, guards } from "@zag-js/core";
import { addDomEvent } from "@zag-js/dom-event";
import { compact } from "@zag-js/utils";
var { not, and, or } = guards;
function createToastMachine(options = {}) {
  const { type = "info", duration, id = "toast", placement = "bottom", removeDelay = 0, ...restProps } = options;
  const ctx = compact(restProps);
  const computedDuration = getToastDuration(duration, type);
  return createMachine(
    {
      id,
      entry: "invokeOnOpen",
      initial: type === "loading" ? "persist" : "active",
      context: {
        id,
        type,
        remaining: computedDuration,
        duration: computedDuration,
        removeDelay,
        createdAt: Date.now(),
        placement,
        ...ctx
      },
      on: {
        UPDATE: [
          {
            guard: and("hasTypeChanged", "isChangingToLoading"),
            target: "persist",
            actions: ["setContext", "invokeOnUpdate"]
          },
          {
            guard: or("hasDurationChanged", "hasTypeChanged"),
            target: "active:temp",
            actions: ["setContext", "invokeOnUpdate"]
          },
          {
            actions: ["setContext", "invokeOnUpdate"]
          }
        ]
      },
      states: {
        "active:temp": {
          tags: ["visible", "updating"],
          after: {
            0: "active"
          }
        },
        persist: {
          tags: ["visible", "paused"],
          activities: "trackDocumentVisibility",
          on: {
            RESUME: {
              guard: not("isLoadingType"),
              target: "active",
              actions: ["setCreatedAt"]
            },
            DISMISS: "dismissing"
          }
        },
        active: {
          tags: ["visible"],
          activities: "trackDocumentVisibility",
          after: {
            VISIBLE_DURATION: "dismissing"
          },
          on: {
            DISMISS: "dismissing",
            PAUSE: {
              target: "persist",
              actions: "setRemainingDuration"
            }
          }
        },
        dismissing: {
          entry: "invokeOnClosing",
          after: {
            REMOVE_DELAY: {
              target: "inactive",
              actions: "notifyParentToRemove"
            }
          }
        },
        inactive: {
          entry: "invokeOnClose",
          type: "final"
        }
      }
    },
    {
      activities: {
        trackDocumentVisibility(ctx2, _evt, { send }) {
          if (!ctx2.pauseOnPageIdle)
            return;
          const doc = dom.getDoc(ctx2);
          return addDomEvent(doc, "visibilitychange", () => {
            send(doc.visibilityState === "hidden" ? "PAUSE" : "RESUME");
          });
        }
      },
      guards: {
        isChangingToLoading: (_, evt) => evt.toast?.type === "loading",
        isLoadingType: (ctx2) => ctx2.type === "loading",
        hasTypeChanged: (ctx2, evt) => evt.toast?.type !== ctx2.type,
        hasDurationChanged: (ctx2, evt) => evt.toast?.duration !== ctx2.duration
      },
      delays: {
        VISIBLE_DURATION: (ctx2) => ctx2.remaining,
        REMOVE_DELAY: (ctx2) => ctx2.removeDelay
      },
      actions: {
        setRemainingDuration(ctx2) {
          ctx2.remaining -= Date.now() - ctx2.createdAt;
        },
        setCreatedAt(ctx2) {
          ctx2.createdAt = Date.now();
        },
        notifyParentToRemove(_ctx, _evt, { self }) {
          self.sendParent({ type: "REMOVE_TOAST", id: self.id });
        },
        invokeOnClosing(ctx2) {
          ctx2.onClosing?.();
        },
        invokeOnClose(ctx2) {
          ctx2.onClose?.();
        },
        invokeOnOpen(ctx2) {
          ctx2.onOpen?.();
        },
        invokeOnUpdate(ctx2) {
          ctx2.onUpdate?.();
        },
        setContext(ctx2, evt) {
          const { duration: duration2, type: type2 } = evt.toast;
          const time = getToastDuration(duration2, type2);
          Object.assign(ctx2, { ...evt.toast, duration: time, remaining: time });
        }
      }
    }
  );
}

// src/toast-group.machine.ts
function groupMachine(userContext) {
  const ctx = compact2(userContext);
  return createMachine2({
    id: "toaster",
    initial: "active",
    context: {
      dir: "ltr",
      max: Number.MAX_SAFE_INTEGER,
      toasts: [],
      gutter: "1rem",
      zIndex: MAX_Z_INDEX,
      pauseOnPageIdle: false,
      pauseOnInteraction: true,
      offsets: { left: "0px", right: "0px", top: "0px", bottom: "0px" },
      ...ctx
    },
    computed: {
      count: (ctx2) => ctx2.toasts.length
    },
    on: {
      PAUSE_TOAST: {
        actions: (_ctx, evt, { self }) => {
          self.sendChild("PAUSE", evt.id);
        }
      },
      PAUSE_ALL: {
        actions: (ctx2) => {
          ctx2.toasts.forEach((toast) => toast.send("PAUSE"));
        }
      },
      RESUME_TOAST: {
        actions: (_ctx, evt, { self }) => {
          self.sendChild("RESUME", evt.id);
        }
      },
      RESUME_ALL: {
        actions: (ctx2) => {
          ctx2.toasts.forEach((toast) => toast.send("RESUME"));
        }
      },
      ADD_TOAST: {
        guard: (ctx2) => ctx2.toasts.length < ctx2.max,
        actions: (ctx2, evt, { self }) => {
          const options = {
            placement: ctx2.placement,
            duration: ctx2.duration,
            removeDelay: ctx2.removeDelay,
            render: ctx2.render,
            ...evt.toast,
            pauseOnPageIdle: ctx2.pauseOnPageIdle,
            pauseOnInteraction: ctx2.pauseOnInteraction,
            dir: ctx2.dir,
            getRootNode: ctx2.getRootNode
          };
          const toast = createToastMachine(options);
          const actor = self.spawn(toast);
          ctx2.toasts.push(actor);
        }
      },
      UPDATE_TOAST: {
        actions: (_ctx, evt, { self }) => {
          self.sendChild({ type: "UPDATE", toast: evt.toast }, evt.id);
        }
      },
      DISMISS_TOAST: {
        actions: (_ctx, evt, { self }) => {
          self.sendChild("DISMISS", evt.id);
        }
      },
      DISMISS_ALL: {
        actions: (ctx2) => {
          ctx2.toasts.forEach((toast) => toast.send("DISMISS"));
        }
      },
      REMOVE_TOAST: {
        actions: (ctx2, evt, { self }) => {
          self.stopChild(evt.id);
          const index = ctx2.toasts.findIndex((toast) => toast.id === evt.id);
          ctx2.toasts.splice(index, 1);
        }
      },
      REMOVE_ALL: {
        actions: (ctx2, _evt, { self }) => {
          ctx2.toasts.forEach((toast) => self.stopChild(toast.id));
          while (ctx2.toasts.length)
            ctx2.toasts.pop();
        }
      }
    }
  });
}

// src/toast.connect.ts
function connect(state, send, normalize) {
  const isVisible = state.hasTag("visible");
  const isPaused = state.hasTag("paused");
  const pauseOnInteraction = state.context.pauseOnInteraction;
  const placement = state.context.placement;
  return {
    type: state.context.type,
    title: state.context.title,
    description: state.context.description,
    placement,
    isVisible,
    isPaused,
    isRtl: state.context.dir === "rtl",
    pause() {
      send("PAUSE");
    },
    resume() {
      send("RESUME");
    },
    dismiss() {
      send("DISMISS");
    },
    rootProps: normalize.element({
      ...parts.root.attrs,
      dir: state.context.dir,
      id: dom.getRootId(state.context),
      "data-state": isVisible ? "open" : "closed",
      "data-type": state.context.type,
      "data-placement": placement,
      role: "status",
      "aria-atomic": "true",
      tabIndex: 0,
      style: {
        position: "relative",
        pointerEvents: "auto",
        margin: "calc(var(--toast-gutter) / 2)",
        "--remove-delay": `${state.context.removeDelay}ms`,
        "--duration": `${state.context.duration}ms`
      },
      onKeyDown(event) {
        if (event.key == "Escape") {
          send("DISMISS");
          event.preventDefault();
        }
      },
      onFocus() {
        if (pauseOnInteraction) {
          send("PAUSE");
        }
      },
      onBlur() {
        if (pauseOnInteraction) {
          send("RESUME");
        }
      },
      onPointerEnter() {
        if (pauseOnInteraction) {
          send("PAUSE");
        }
      },
      onPointerLeave() {
        if (pauseOnInteraction) {
          send("RESUME");
        }
      }
    }),
    titleProps: normalize.element({
      ...parts.title.attrs,
      id: dom.getTitleId(state.context)
    }),
    descriptionProps: normalize.element({
      ...parts.description.attrs,
      id: dom.getDescriptionId(state.context)
    }),
    closeTriggerProps: normalize.button({
      id: dom.getCloseTriggerId(state.context),
      ...parts.closeTrigger.attrs,
      type: "button",
      "aria-label": "Dismiss notification",
      onClick() {
        send("DISMISS");
      }
    })
  };
}

// src/index.ts
var group = {
  connect: groupConnect,
  machine: groupMachine
};
export {
  anatomy,
  connect,
  createToastMachine as createMachine,
  group
};
//# sourceMappingURL=index.mjs.map