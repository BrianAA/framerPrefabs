"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  anatomy: () => anatomy,
  connect: () => connect,
  machine: () => machine
});
module.exports = __toCommonJS(src_exports);

// src/menu.anatomy.ts
var import_anatomy = require("@zag-js/anatomy");
var anatomy = (0, import_anatomy.createAnatomy)("menu").parts(
  "contextTrigger",
  "trigger",
  "triggerItem",
  "indicator",
  "positioner",
  "arrow",
  "arrowTip",
  "content",
  "separator",
  "item",
  "optionItem",
  "optionItemIndicator",
  "optionItemText",
  "itemGroupLabel",
  "itemGroup"
);
var parts = anatomy.build();

// src/menu.connect.ts
var import_core = require("@zag-js/core");
var import_dom_event = require("@zag-js/dom-event");
var import_dom_query2 = require("@zag-js/dom-query");
var import_popper = require("@zag-js/popper");
var import_utils2 = require("@zag-js/utils");

// src/menu.dom.ts
var import_dom_query = require("@zag-js/dom-query");
var import_utils = require("@zag-js/utils");
var dom = (0, import_dom_query.createScope)({
  getTriggerId: (ctx) => ctx.ids?.trigger ?? `menu:${ctx.id}:trigger`,
  getContextTriggerId: (ctx) => ctx.ids?.contextTrigger ?? `menu:${ctx.id}:ctx-trigger`,
  getContentId: (ctx) => ctx.ids?.content ?? `menu:${ctx.id}:content`,
  getArrowId: (ctx) => ctx.ids?.arrow ?? `menu:${ctx.id}:arrow`,
  getPositionerId: (ctx) => ctx.ids?.positioner ?? `menu:${ctx.id}:popper`,
  getGroupId: (ctx, id) => ctx.ids?.group?.(id) ?? `menu:${ctx.id}:group:${id}`,
  getGroupLabelId: (ctx, id) => ctx.ids?.label?.(id) ?? `menu:${ctx.id}:label:${id}`,
  getContentEl: (ctx) => dom.getById(ctx, dom.getContentId(ctx)),
  getPositionerEl: (ctx) => dom.getById(ctx, dom.getPositionerId(ctx)),
  getTriggerEl: (ctx) => dom.getById(ctx, dom.getTriggerId(ctx)),
  getFocusedItem: (ctx) => ctx.highlightedId ? dom.getById(ctx, ctx.highlightedId) : null,
  getArrowEl: (ctx) => dom.getById(ctx, dom.getArrowId(ctx)),
  getElements: (ctx) => {
    const ownerId = CSS.escape(dom.getContentId(ctx));
    const selector = `[role^="menuitem"][data-ownedby=${ownerId}]:not([data-disabled])`;
    return (0, import_dom_query.queryAll)(dom.getContentEl(ctx), selector);
  },
  getFirstEl: (ctx) => (0, import_utils.first)(dom.getElements(ctx)),
  getLastEl: (ctx) => (0, import_utils.last)(dom.getElements(ctx)),
  getNextEl: (ctx, loop) => (0, import_dom_query.nextById)(dom.getElements(ctx), ctx.highlightedId, loop ?? ctx.loop),
  getPrevEl: (ctx, loop) => (0, import_dom_query.prevById)(dom.getElements(ctx), ctx.highlightedId, loop ?? ctx.loop),
  getElemByKey: (ctx, key) => (0, import_dom_query.getByTypeahead)(dom.getElements(ctx), { state: ctx.typeahead, key, activeId: ctx.highlightedId }),
  isTargetDisabled: (v) => {
    return (0, import_dom_query.isHTMLElement)(v) && (v.dataset.disabled === "" || v.hasAttribute("disabled"));
  },
  isTriggerItem: (el) => {
    return !!el?.getAttribute("role")?.startsWith("menuitem") && !!el?.hasAttribute("aria-controls");
  },
  getHighlightedOptionEl(ctx) {
    if (!ctx.highlightedId)
      return null;
    return dom.getById(ctx, ctx.highlightedId);
  }
});

// src/menu.connect.ts
function connect(state, send, normalize) {
  const isSubmenu = state.context.isSubmenu;
  const values = state.context.value;
  const isTypingAhead = state.context.isTypingAhead;
  const isOpen = state.hasTag("visible");
  const popperStyles = (0, import_popper.getPlacementStyles)({
    ...state.context.positioning,
    placement: state.context.currentPlacement
  });
  function getItemState(props) {
    return {
      isDisabled: !!props.disabled,
      isHighlighted: state.context.highlightedId === props.id
    };
  }
  function getOptionItemProps(props) {
    const id = props.id ?? props.value;
    const valueText = props.valueText ?? props.value;
    return { ...props, id, valueText };
  }
  function getOptionItemState(props) {
    const itemState = getItemState(getOptionItemProps(props));
    return {
      ...itemState,
      isChecked: !!(0, import_utils2.match)(props.type, {
        radio: () => values?.[props.name] === props.value,
        checkbox: () => values?.[props.name].includes(props.value)
      })
    };
  }
  function getItemProps(props) {
    const { id, closeOnSelect, valueText } = props;
    const itemState = getItemState(props);
    return normalize.element({
      ...parts.item.attrs,
      id,
      role: "menuitem",
      "aria-disabled": itemState.isDisabled,
      "data-disabled": (0, import_dom_query2.dataAttr)(itemState.isDisabled),
      "data-ownedby": dom.getContentId(state.context),
      "data-highlighted": (0, import_dom_query2.dataAttr)(itemState.isHighlighted),
      "data-valuetext": valueText,
      onDragStart(event) {
        const isLink = event.currentTarget.matches("a[href]");
        if (isLink)
          event.preventDefault();
      },
      onPointerLeave(event) {
        if (itemState.isDisabled || event.pointerType !== "mouse")
          return;
        const target = event.currentTarget;
        send({ type: "ITEM_POINTERLEAVE", id, target, closeOnSelect });
      },
      onPointerMove(event) {
        if (itemState.isDisabled || event.pointerType !== "mouse")
          return;
        const target = event.currentTarget;
        send({ type: "ITEM_POINTERMOVE", id, target, closeOnSelect });
      },
      onPointerDown(event) {
        if (itemState.isDisabled)
          return;
        const target = event.currentTarget;
        send({ type: "ITEM_POINTERDOWN", target, id, closeOnSelect });
      },
      onPointerUp(event) {
        const evt = (0, import_dom_event.getNativeEvent)(event);
        if (!(0, import_dom_event.isLeftClick)(evt) || itemState.isDisabled)
          return;
        const target = event.currentTarget;
        send({ type: "ITEM_CLICK", src: "pointerup", target, id, closeOnSelect });
        if (target.matches("a[href]") && event.pointerType === "touch") {
          target.click();
        }
      }
    });
  }
  return {
    highlightedId: state.context.highlightedId,
    isOpen,
    open() {
      send("OPEN");
    },
    close() {
      send("CLOSE");
    },
    setHighlightedId(id) {
      send({ type: "SET_HIGHLIGHTED_ID", id });
    },
    setParent(parent) {
      send({ type: "SET_PARENT", value: parent, id: parent.state.context.id });
    },
    setChild(child) {
      send({ type: "SET_CHILD", value: child, id: child.state.context.id });
    },
    value: values,
    setValue(name, value) {
      send({ type: "SET_VALUE", name, value });
    },
    reposition(options = {}) {
      send({ type: "SET_POSITIONING", options });
    },
    contextTriggerProps: normalize.element({
      ...parts.contextTrigger.attrs,
      dir: state.context.dir,
      id: dom.getContextTriggerId(state.context),
      onPointerDown(event) {
        if (event.pointerType === "mouse")
          return;
        const evt = (0, import_dom_event.getNativeEvent)(event);
        const point = (0, import_dom_event.getEventPoint)(evt);
        send({ type: "CONTEXT_MENU_START", point });
      },
      onPointerCancel(event) {
        if (event.pointerType === "mouse")
          return;
        send("CONTEXT_MENU_CANCEL");
      },
      onPointerMove(event) {
        if (event.pointerType === "mouse")
          return;
        send("CONTEXT_MENU_CANCEL");
      },
      onPointerUp(event) {
        if (event.pointerType === "mouse")
          return;
        send("CONTEXT_MENU_CANCEL");
      },
      onContextMenu(event) {
        const evt = (0, import_dom_event.getNativeEvent)(event);
        const point = (0, import_dom_event.getEventPoint)(evt);
        send({ type: "CONTEXT_MENU", point });
        event.preventDefault();
      },
      style: {
        WebkitTouchCallout: "none",
        userSelect: "none"
      }
    }),
    getTriggerItemProps(childApi) {
      return (0, import_core.mergeProps)(getItemProps({ id: childApi.triggerProps.id }), childApi.triggerProps);
    },
    triggerProps: normalize.button({
      ...isSubmenu ? parts.triggerItem.attrs : parts.trigger.attrs,
      "data-placement": state.context.currentPlacement,
      type: "button",
      dir: state.context.dir,
      id: dom.getTriggerId(state.context),
      "data-uid": state.context.id,
      "aria-haspopup": "menu",
      "aria-controls": dom.getContentId(state.context),
      "aria-expanded": isOpen || void 0,
      "data-state": isOpen ? "open" : "closed",
      onPointerMove(event) {
        if (event.pointerType !== "mouse")
          return;
        const disabled = dom.isTargetDisabled(event.currentTarget);
        if (disabled || !isSubmenu)
          return;
        send({ type: "TRIGGER_POINTERMOVE", target: event.currentTarget });
      },
      onPointerLeave(event) {
        if (event.pointerType !== "mouse")
          return;
        const evt = (0, import_dom_event.getNativeEvent)(event);
        const disabled = dom.isTargetDisabled(event.currentTarget);
        if (disabled || !isSubmenu)
          return;
        const point = (0, import_dom_event.getEventPoint)(evt);
        send({ type: "TRIGGER_POINTERLEAVE", target: event.currentTarget, point });
      },
      onClick(event) {
        if (dom.isTriggerItem(event.currentTarget)) {
          send({ type: "TRIGGER_CLICK", target: event.currentTarget });
        }
      },
      onPointerDown(event) {
        const disabled = dom.isTargetDisabled(event.currentTarget);
        const evt = (0, import_dom_event.getNativeEvent)(event);
        if (!(0, import_dom_event.isLeftClick)(evt) || disabled || (0, import_dom_event.isContextMenuEvent)(event))
          return;
        event.preventDefault();
        if (!dom.isTriggerItem(event.currentTarget)) {
          send({ type: "TRIGGER_CLICK", target: event.currentTarget });
        }
      },
      onBlur() {
        send("TRIGGER_BLUR");
      },
      onFocus() {
        send("TRIGGER_FOCUS");
      },
      onKeyDown(event) {
        const keyMap = {
          ArrowDown() {
            send("ARROW_DOWN");
          },
          ArrowUp() {
            send("ARROW_UP");
          },
          Enter() {
            send({ type: "ARROW_DOWN" });
          },
          Space() {
            send({ type: "ARROW_DOWN" });
          }
        };
        const key = (0, import_dom_event.getEventKey)(event, state.context);
        const exec = keyMap[key];
        if (exec) {
          event.preventDefault();
          exec(event);
        }
      }
    }),
    indicatorProps: normalize.element({
      ...parts.indicator.attrs,
      dir: state.context.dir,
      "data-state": isOpen ? "open" : "closed"
    }),
    positionerProps: normalize.element({
      ...parts.positioner.attrs,
      dir: state.context.dir,
      id: dom.getPositionerId(state.context),
      style: popperStyles.floating
    }),
    arrowProps: normalize.element({
      id: dom.getArrowId(state.context),
      ...parts.arrow.attrs,
      dir: state.context.dir,
      style: popperStyles.arrow
    }),
    arrowTipProps: normalize.element({
      ...parts.arrowTip.attrs,
      dir: state.context.dir,
      style: popperStyles.arrowTip
    }),
    contentProps: normalize.element({
      ...parts.content.attrs,
      id: dom.getContentId(state.context),
      "aria-label": state.context["aria-label"],
      hidden: !isOpen,
      "data-state": isOpen ? "open" : "closed",
      role: "menu",
      tabIndex: 0,
      dir: state.context.dir,
      "aria-activedescendant": state.context.highlightedId ?? void 0,
      "aria-labelledby": dom.getTriggerId(state.context),
      "data-placement": state.context.currentPlacement,
      onPointerEnter(event) {
        if (event.pointerType !== "mouse")
          return;
        send("MENU_POINTERENTER");
      },
      onKeyDown(event) {
        const target = (0, import_dom_query2.getEventTarget)((0, import_dom_event.getNativeEvent)(event));
        const isKeyDownInside = target?.closest("[role=menu]") === event.currentTarget;
        if (!(0, import_dom_query2.isSelfEvent)(event) || !isKeyDownInside)
          return;
        const item = dom.getFocusedItem(state.context);
        const isLink = !!item?.matches("a[href]");
        const keyMap = {
          ArrowDown() {
            send("ARROW_DOWN");
          },
          ArrowUp() {
            send("ARROW_UP");
          },
          ArrowLeft() {
            send("ARROW_LEFT");
          },
          ArrowRight() {
            send("ARROW_RIGHT");
          },
          Enter() {
            if (isLink)
              item?.click();
            send("ENTER");
          },
          Space(event2) {
            if (isTypingAhead) {
              send({ type: "TYPEAHEAD", key: event2.key });
            } else {
              keyMap.Enter?.(event2);
            }
          },
          Home() {
            send("HOME");
          },
          End() {
            send("END");
          },
          Tab(event2) {
            send({ type: "TAB", shiftKey: event2.shiftKey, loop: false });
          }
        };
        const key = (0, import_dom_event.getEventKey)(event, { dir: state.context.dir });
        const exec = keyMap[key];
        if (exec) {
          const allow = isLink && key === "Enter";
          exec(event);
          if (!allow) {
            event.preventDefault();
          }
        } else {
          const isSingleKey = event.key.length === 1;
          const isValidTypeahead = isSingleKey && !(0, import_dom_event.isModifiedEvent)(event) && !(0, import_dom_query2.isEditableElement)(item);
          if (!isValidTypeahead)
            return;
          send({ type: "TYPEAHEAD", key: event.key });
          event.preventDefault();
        }
      }
    }),
    separatorProps: normalize.element({
      ...parts.separator.attrs,
      role: "separator",
      dir: state.context.dir,
      "aria-orientation": "horizontal"
    }),
    getItemState,
    getItemProps,
    getOptionItemState,
    getOptionItemProps(props) {
      const { name, type, disabled, onCheckedChange, closeOnSelect } = props;
      const option = getOptionItemProps(props);
      const itemState = getOptionItemState(props);
      return {
        ...getItemProps(option),
        ...normalize.element({
          "data-type": type,
          "data-name": name,
          ...parts.optionItem.attrs,
          dir: state.context.dir,
          "data-value": option.value,
          role: `menuitem${type}`,
          "aria-checked": !!itemState.isChecked,
          "data-state": itemState.isChecked ? "checked" : "unchecked",
          onPointerUp(event) {
            const evt = (0, import_dom_event.getNativeEvent)(event);
            if (!(0, import_dom_event.isLeftClick)(evt) || disabled)
              return;
            const target = event.currentTarget;
            send({ type: "ITEM_CLICK", src: "pointerup", target, option, closeOnSelect });
            onCheckedChange?.(!itemState.isChecked);
          }
        })
      };
    },
    getOptionItemIndicatorProps(props) {
      const itemState = getOptionItemState(props);
      return normalize.element({
        ...parts.optionItemIndicator.attrs,
        dir: state.context.dir,
        "data-disabled": (0, import_dom_query2.dataAttr)(itemState.isDisabled),
        "data-highlighted": (0, import_dom_query2.dataAttr)(itemState.isHighlighted),
        "data-state": itemState.isChecked ? "checked" : "unchecked",
        hidden: !itemState.isChecked
      });
    },
    getOptionItemTextProps(props) {
      const itemState = getOptionItemState(props);
      return normalize.element({
        ...parts.optionItemText.attrs,
        dir: state.context.dir,
        "data-disabled": (0, import_dom_query2.dataAttr)(itemState.isDisabled),
        "data-highlighted": (0, import_dom_query2.dataAttr)(itemState.isHighlighted),
        "data-state": itemState.isChecked ? "checked" : "unchecked"
      });
    },
    getItemGroupLabelProps(props) {
      return normalize.element({
        id: dom.getGroupLabelId(state.context, props.htmlFor),
        dir: state.context.dir,
        ...parts.itemGroupLabel.attrs
      });
    },
    getItemGroupProps(props) {
      return normalize.element({
        id: dom.getGroupId(state.context, props.id),
        ...parts.itemGroup.attrs,
        dir: state.context.dir,
        "aria-labelledby": dom.getGroupLabelId(state.context, props.id),
        role: "group"
      });
    }
  };
}

// src/menu.machine.ts
var import_core2 = require("@zag-js/core");
var import_dismissable = require("@zag-js/dismissable");
var import_dom_event2 = require("@zag-js/dom-event");
var import_dom_query3 = require("@zag-js/dom-query");
var import_mutation_observer = require("@zag-js/mutation-observer");
var import_popper2 = require("@zag-js/popper");
var import_rect_utils = require("@zag-js/rect-utils");
var import_utils3 = require("@zag-js/utils");
var { not, and } = import_core2.guards;
function machine(userContext) {
  const ctx = (0, import_utils3.compact)(userContext);
  return (0, import_core2.createMachine)(
    {
      id: "menu",
      initial: ctx.open ? "open" : "idle",
      context: {
        highlightedId: null,
        hoverId: null,
        parent: null,
        children: (0, import_utils3.cast)((0, import_core2.ref)({})),
        intentPolygon: null,
        loop: false,
        suspendPointer: false,
        anchorPoint: null,
        closeOnSelect: true,
        focusTriggerOnClose: true,
        ...ctx,
        typeahead: import_dom_query3.getByTypeahead.defaultOptions,
        positioning: {
          placement: "bottom-start",
          gutter: 8,
          ...ctx.positioning
        }
      },
      computed: {
        isSubmenu: (ctx2) => ctx2.parent !== null,
        isRtl: (ctx2) => ctx2.dir === "rtl",
        isTypingAhead: (ctx2) => ctx2.typeahead.keysSoFar !== ""
      },
      watch: {
        isSubmenu: "setSubmenuPlacement",
        anchorPoint: "reposition",
        open: "toggleVisibility"
      },
      on: {
        SET_PARENT: {
          actions: "setParentMenu"
        },
        SET_CHILD: {
          actions: "setChildMenu"
        },
        OPEN: {
          target: "open",
          actions: "invokeOnOpen"
        },
        OPEN_AUTOFOCUS: {
          internal: true,
          target: "open",
          actions: ["focusFirstItem", "invokeOnOpen"]
        },
        CLOSE: {
          target: "closed",
          actions: "invokeOnClose"
        },
        RESTORE_FOCUS: {
          actions: "restoreFocus"
        },
        SET_VALUE: {
          actions: ["setOptionValue", "invokeOnValueChange"]
        },
        SET_HIGHLIGHTED_ID: {
          actions: "setFocusedItem"
        }
      },
      states: {
        idle: {
          on: {
            CONTEXT_MENU_START: {
              target: "opening:contextmenu",
              actions: "setAnchorPoint"
            },
            CONTEXT_MENU: {
              target: "open",
              actions: ["setAnchorPoint", "invokeOnOpen"]
            },
            TRIGGER_CLICK: {
              target: "open",
              actions: "invokeOnOpen"
            },
            TRIGGER_FOCUS: {
              guard: not("isSubmenu"),
              target: "closed"
            },
            TRIGGER_POINTERMOVE: {
              guard: "isSubmenu",
              target: "opening"
            }
          }
        },
        "opening:contextmenu": {
          after: {
            LONG_PRESS_DELAY: {
              target: "open",
              actions: "invokeOnOpen"
            }
          },
          on: {
            CONTEXT_MENU_CANCEL: {
              target: "closed",
              actions: "invokeOnClose"
            }
          }
        },
        opening: {
          after: {
            SUBMENU_OPEN_DELAY: {
              target: "open",
              actions: "invokeOnOpen"
            }
          },
          on: {
            BLUR: {
              target: "closed",
              actions: "invokeOnClose"
            },
            TRIGGER_POINTERLEAVE: {
              target: "closed",
              actions: "invokeOnClose"
            }
          }
        },
        closing: {
          tags: ["visible"],
          activities: ["trackPointerMove", "trackInteractOutside"],
          after: {
            SUBMENU_CLOSE_DELAY: {
              target: "closed",
              actions: ["focusParentMenu", "restoreParentFocus", "invokeOnClose"]
            }
          },
          on: {
            MENU_POINTERENTER: {
              target: "open",
              actions: "clearIntentPolygon"
            },
            POINTER_MOVED_AWAY_FROM_SUBMENU: {
              target: "closed",
              actions: ["focusParentMenu", "restoreParentFocus"]
            }
          }
        },
        closed: {
          entry: ["clearFocusedItem", "focusTrigger", "clearAnchorPoint", "resumePointer"],
          on: {
            CONTEXT_MENU_START: {
              target: "opening:contextmenu",
              actions: "setAnchorPoint"
            },
            CONTEXT_MENU: {
              target: "open",
              actions: ["setAnchorPoint", "invokeOnOpen"]
            },
            TRIGGER_CLICK: {
              target: "open",
              actions: "invokeOnOpen"
            },
            TRIGGER_POINTERMOVE: {
              guard: "isTriggerItem",
              target: "opening"
            },
            TRIGGER_BLUR: "idle",
            ARROW_DOWN: {
              target: "open",
              actions: ["focusFirstItem", "invokeOnOpen"]
            },
            ARROW_UP: {
              target: "open",
              actions: ["focusLastItem", "invokeOnOpen"]
            }
          }
        },
        open: {
          tags: ["visible"],
          activities: ["trackInteractOutside", "trackPositioning", "scrollToHighlightedItem"],
          entry: ["focusMenu", "resumePointer"],
          on: {
            TRIGGER_CLICK: {
              guard: not("isTriggerItem"),
              target: "closed",
              actions: "invokeOnClose"
            },
            TAB: [
              {
                guard: "isForwardTabNavigation",
                actions: ["focusNextItem"]
              },
              { actions: ["focusPrevItem"] }
            ],
            ARROW_UP: {
              actions: ["focusPrevItem", "focusMenu"]
            },
            ARROW_DOWN: {
              actions: ["focusNextItem", "focusMenu"]
            },
            ARROW_LEFT: {
              guard: "isSubmenu",
              target: "closed",
              actions: ["focusParentMenu", "invokeOnClose"]
            },
            HOME: {
              actions: ["focusFirstItem", "focusMenu"]
            },
            END: {
              actions: ["focusLastItem", "focusMenu"]
            },
            REQUEST_CLOSE: {
              target: "closed",
              actions: "invokeOnClose"
            },
            ARROW_RIGHT: {
              guard: "isTriggerItemFocused",
              actions: "openSubmenu"
            },
            ENTER: [
              {
                guard: "isTriggerItemFocused",
                actions: "openSubmenu"
              },
              {
                guard: "closeOnSelect",
                target: "closed",
                actions: "clickFocusedItem"
              },
              {
                actions: "clickFocusedItem"
              }
            ],
            ITEM_POINTERMOVE: [
              {
                guard: and(not("suspendPointer"), not("isTargetFocused")),
                actions: ["focusItem", "focusMenu"]
              },
              {
                guard: not("isTargetFocused"),
                actions: "setHoveredItem"
              }
            ],
            ITEM_POINTERLEAVE: {
              guard: and(not("suspendPointer"), not("isTriggerItem")),
              actions: "clearFocusedItem"
            },
            ITEM_CLICK: [
              {
                guard: and(not("isTriggerItemFocused"), not("isFocusedItemEditable"), "closeOnSelect"),
                target: "closed",
                actions: [
                  "invokeOnSelect",
                  "changeOptionValue",
                  "invokeOnValueChange",
                  "closeRootMenu",
                  "invokeOnClose"
                ]
              },
              {
                guard: and(not("isTriggerItemFocused"), not("isFocusedItemEditable")),
                actions: ["invokeOnSelect", "changeOptionValue", "invokeOnValueChange"]
              },
              { actions: "focusItem" }
            ],
            TRIGGER_POINTERLEAVE: {
              target: "closing",
              actions: "setIntentPolygon"
            },
            ITEM_POINTERDOWN: {
              actions: "focusItem"
            },
            TYPEAHEAD: {
              actions: "focusMatchedItem"
            },
            FOCUS_MENU: {
              actions: "focusMenu"
            },
            SET_POSITIONING: {
              actions: "reposition"
            }
          }
        }
      }
    },
    {
      delays: {
        LONG_PRESS_DELAY: 700,
        SUBMENU_OPEN_DELAY: 100,
        SUBMENU_CLOSE_DELAY: 100
      },
      guards: {
        closeOnSelect: (ctx2, evt) => !!(evt?.closeOnSelect ?? ctx2.closeOnSelect),
        isMenuFocused: (ctx2) => (0, import_dom_query3.contains)(dom.getContentEl(ctx2), dom.getActiveElement(ctx2)),
        isTargetFocused: (ctx2, evt) => ctx2.highlightedId === evt.target.id,
        // whether the trigger is also a menu item
        isTriggerItem: (_ctx, evt) => dom.isTriggerItem(evt.target),
        // whether the trigger item is the active item
        isTriggerItemFocused: (ctx2, evt) => {
          const target = evt.target ?? dom.getFocusedItem(ctx2);
          return !!target?.hasAttribute("aria-controls");
        },
        isForwardTabNavigation: (_ctx, evt) => !evt.shiftKey,
        isSubmenu: (ctx2) => ctx2.isSubmenu,
        suspendPointer: (ctx2) => ctx2.suspendPointer,
        isFocusedItemEditable: (ctx2) => (0, import_dom_query3.isEditableElement)(dom.getFocusedItem(ctx2)),
        isWithinPolygon: (ctx2, evt) => {
          if (!ctx2.intentPolygon)
            return false;
          return (0, import_rect_utils.isPointInPolygon)(ctx2.intentPolygon, evt.point);
        }
      },
      activities: {
        trackPositioning(ctx2) {
          if (ctx2.anchorPoint)
            return;
          ctx2.currentPlacement = ctx2.positioning.placement;
          const getPositionerEl = () => dom.getPositionerEl(ctx2);
          return (0, import_popper2.getPlacement)(dom.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackInteractOutside(ctx2, _evt, { send }) {
          const getContentEl = () => dom.getContentEl(ctx2);
          return (0, import_dismissable.trackDismissableElement)(getContentEl, {
            defer: true,
            exclude: [dom.getTriggerEl(ctx2)],
            onInteractOutside: ctx2.onInteractOutside,
            onFocusOutside: ctx2.onFocusOutside,
            onEscapeKeyDown(event) {
              if (ctx2.isSubmenu)
                event.preventDefault();
              closeRootMenu(ctx2);
            },
            onPointerDownOutside(event) {
              ctx2.focusTriggerOnClose = !event.detail.focusable;
              ctx2.onPointerDownOutside?.(event);
            },
            onDismiss() {
              send({ type: "REQUEST_CLOSE", src: "interact-outside" });
            }
          });
        },
        trackPointerMove(ctx2, _evt, { guards: guards2, send }) {
          const { isWithinPolygon } = guards2;
          ctx2.parent.state.context.suspendPointer = true;
          const doc = dom.getDoc(ctx2);
          return (0, import_dom_event2.addDomEvent)(doc, "pointermove", (e) => {
            const point = { x: e.clientX, y: e.clientY };
            const isMovingToSubmenu = isWithinPolygon(ctx2, { point });
            if (!isMovingToSubmenu) {
              send("POINTER_MOVED_AWAY_FROM_SUBMENU");
              ctx2.parent.state.context.suspendPointer = false;
            }
          });
        },
        scrollToHighlightedItem(ctx2, _evt, { getState }) {
          const exec = () => {
            const state = getState();
            if (state.event.type.startsWith("ITEM_POINTER"))
              return;
            const optionEl = dom.getHighlightedOptionEl(ctx2);
            optionEl?.scrollIntoView({ block: "nearest" });
          };
          (0, import_dom_query3.raf)(() => exec());
          return (0, import_mutation_observer.observeAttributes)(dom.getContentEl(ctx2), ["aria-activedescendant"], exec);
        }
      },
      actions: {
        setAnchorPoint(ctx2, evt) {
          ctx2.anchorPoint = evt.point;
        },
        clearAnchorPoint(ctx2) {
          ctx2.anchorPoint = null;
        },
        setSubmenuPlacement(ctx2) {
          if (!ctx2.isSubmenu)
            return;
          ctx2.positioning.placement = ctx2.isRtl ? "left-start" : "right-start";
          ctx2.positioning.gutter = 0;
        },
        reposition(ctx2, evt) {
          const getPositionerEl = () => dom.getPositionerEl(ctx2);
          const getAnchorRect = ctx2.anchorPoint ? () => ({ width: 0, height: 0, ...ctx2.anchorPoint }) : void 0;
          (0, import_popper2.getPlacement)(dom.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            getAnchorRect,
            ...evt.options ?? {},
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        invokeOnValueChange(ctx2, evt) {
          if (!ctx2.value)
            return;
          const name = evt.name ?? evt.option?.name;
          if (!name)
            return;
          const values = ctx2.value[name];
          const valueAsArray = (0, import_utils3.isArray)(values) ? Array.from(values) : values;
          ctx2.onValueChange?.({ name, value: valueAsArray });
        },
        setOptionValue(ctx2, evt) {
          if (!ctx2.value)
            return;
          ctx2.value[evt.name] = evt.value;
        },
        changeOptionValue(ctx2, evt) {
          if (!evt.option || !ctx2.value)
            return;
          const { value, type, name } = evt.option;
          const values = ctx2.value[name];
          if (type === "checkbox" && (0, import_utils3.isArray)(values)) {
            ctx2.value[name] = values.includes(value) ? (0, import_utils3.remove)(values, value) : (0, import_utils3.add)(values, value);
          } else {
            ctx2.value[name] = value;
          }
        },
        clickFocusedItem(ctx2, _evt, { send }) {
          const itemEl = dom.getFocusedItem(ctx2);
          if (!itemEl || itemEl.dataset.disabled)
            return;
          const option = {
            id: itemEl.id,
            name: itemEl.dataset.name,
            value: itemEl.dataset.value,
            valueText: itemEl.dataset.valueText,
            type: itemEl.dataset.type
          };
          send({
            type: "ITEM_CLICK",
            src: "enter",
            target: itemEl,
            id: option.id,
            option,
            closeOnSelect: ctx2.closeOnSelect
          });
        },
        setIntentPolygon(ctx2, evt) {
          const menu = dom.getContentEl(ctx2);
          const placement = ctx2.currentPlacement;
          if (!menu || !placement)
            return;
          const rect = menu.getBoundingClientRect();
          const polygon = (0, import_rect_utils.getElementPolygon)(rect, placement);
          if (!polygon)
            return;
          const rightSide = (0, import_popper2.getPlacementSide)(placement) === "right";
          const bleed = rightSide ? -5 : 5;
          ctx2.intentPolygon = [{ ...evt.point, x: evt.point.x + bleed }, ...polygon];
        },
        clearIntentPolygon(ctx2) {
          ctx2.intentPolygon = null;
        },
        resumePointer(ctx2) {
          if (!ctx2.parent)
            return;
          ctx2.parent.state.context.suspendPointer = false;
        },
        setFocusedItem(ctx2, evt) {
          ctx2.highlightedId = evt.id;
        },
        clearFocusedItem(ctx2) {
          ctx2.highlightedId = null;
        },
        focusMenu(ctx2) {
          (0, import_dom_query3.raf)(() => {
            const activeEl = dom.getActiveElement(ctx2);
            const contentEl = dom.getContentEl(ctx2);
            if ((0, import_dom_query3.contains)(contentEl, activeEl))
              return;
            contentEl?.focus({ preventScroll: true });
          });
        },
        focusFirstItem(ctx2) {
          const first2 = dom.getFirstEl(ctx2);
          if (!first2)
            return;
          ctx2.highlightedId = first2.id;
        },
        focusLastItem(ctx2) {
          const last2 = dom.getLastEl(ctx2);
          if (!last2)
            return;
          ctx2.highlightedId = last2.id;
        },
        focusNextItem(ctx2, evt) {
          const next = dom.getNextEl(ctx2, evt.loop);
          ctx2.highlightedId = next?.id ?? null;
        },
        focusPrevItem(ctx2, evt) {
          const prev = dom.getPrevEl(ctx2, evt.loop);
          ctx2.highlightedId = prev?.id ?? null;
        },
        invokeOnSelect(ctx2) {
          if (!ctx2.highlightedId)
            return;
          ctx2.onSelect?.({ value: ctx2.highlightedId });
        },
        focusItem(ctx2, evt) {
          ctx2.highlightedId = evt.id;
        },
        focusTrigger(ctx2) {
          if (ctx2.isSubmenu || ctx2.anchorPoint || !ctx2.focusTriggerOnClose)
            return;
          (0, import_dom_query3.raf)(() => dom.getTriggerEl(ctx2)?.focus({ preventScroll: true }));
        },
        focusMatchedItem(ctx2, evt) {
          const node = dom.getElemByKey(ctx2, evt.key);
          if (node)
            ctx2.highlightedId = node.id;
        },
        setParentMenu(ctx2, evt) {
          ctx2.parent = (0, import_core2.ref)(evt.value);
        },
        setChildMenu(ctx2, evt) {
          ctx2.children[evt.id] = (0, import_core2.ref)(evt.value);
        },
        closeRootMenu(ctx2) {
          closeRootMenu(ctx2);
        },
        openSubmenu(ctx2) {
          const item = dom.getFocusedItem(ctx2);
          const id = item?.getAttribute("data-uid");
          const child = id ? ctx2.children[id] : null;
          child?.send("OPEN_AUTOFOCUS");
        },
        focusParentMenu(ctx2) {
          ctx2.parent?.send("FOCUS_MENU");
        },
        setHoveredItem(ctx2, evt) {
          ctx2.hoverId = evt.id;
        },
        restoreFocus(ctx2) {
          if (!ctx2.hoverId)
            return;
          ctx2.highlightedId = ctx2.hoverId;
          ctx2.hoverId = null;
        },
        restoreParentFocus(ctx2) {
          ctx2.parent?.send("RESTORE_FOCUS");
        },
        invokeOnOpen(ctx2) {
          ctx2.onOpenChange?.({ open: true });
        },
        invokeOnClose(ctx2) {
          ctx2.onOpenChange?.({ open: false });
        },
        toggleVisibility(ctx2, _evt, { send }) {
          send({ type: ctx2.open ? "OPEN" : "CLOSE" });
        }
      }
    }
  );
}
function closeRootMenu(ctx) {
  let parent = ctx.parent;
  while (parent && parent.state.context.isSubmenu) {
    parent = parent.state.context.parent;
  }
  parent?.send("CLOSE");
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  anatomy,
  connect,
  machine
});
//# sourceMappingURL=index.js.map