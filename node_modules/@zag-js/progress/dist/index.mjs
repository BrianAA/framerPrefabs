// src/progress.anatomy.ts
import { createAnatomy } from "@zag-js/anatomy";
var anatomy = createAnatomy("progress").parts(
  "root",
  "label",
  "track",
  "range",
  "valueText",
  "indicator",
  "circle",
  "circleTrack",
  "circleRange"
);
var parts = anatomy.build();

// src/progress.dom.ts
import { createScope } from "@zag-js/dom-query";
var dom = createScope({
  getRootId: (ctx) => `progress-${ctx.id}`,
  getTrackId: (ctx) => `progress-${ctx.id}-track`,
  getLabelId: (ctx) => `progress-${ctx.id}-label`,
  getCircleId: (ctx) => `progress-${ctx.id}-circle`
});

// src/progress.connect.ts
function connect(state, send, normalize) {
  const percent = state.context.percent;
  const max = state.context.max;
  const min = state.context.min;
  const orientation = state.context.orientation;
  const translations = state.context.translations;
  const indeterminate = state.context.isIndeterminate;
  const value = state.context.value;
  const valueAsString = translations.value({ value, max, percent, min });
  const progressState = getProgressState(value, max);
  const progressbarProps = {
    role: "progressbar",
    "aria-label": valueAsString,
    "data-max": max,
    "aria-valuemin": min,
    "aria-valuemax": max,
    "aria-valuenow": value ?? void 0,
    "data-orientation": orientation,
    "data-state": progressState
  };
  const circleProps = getCircleProps(state.context);
  return {
    value,
    valueAsString,
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2 });
    },
    setToMax() {
      send({ type: "VALUE.SET", value: max });
    },
    rootProps: normalize.element({
      dir: state.context.dir,
      ...parts.root.attrs,
      id: dom.getRootId(state.context),
      "data-max": max,
      "data-value": value ?? void 0,
      "data-state": progressState,
      "data-orientation": orientation,
      style: {
        "--percent": indeterminate ? void 0 : percent
      }
    }),
    labelProps: normalize.element({
      dir: state.context.dir,
      id: dom.getLabelId(state.context),
      ...parts.label.attrs,
      "data-orientation": orientation
    }),
    valueTextProps: normalize.element({
      dir: state.context.dir,
      "aria-live": "polite",
      ...parts.valueText.attrs
    }),
    trackProps: normalize.element({
      dir: state.context.dir,
      id: dom.getTrackId(state.context),
      ...parts.track.attrs,
      ...progressbarProps
    }),
    rangeProps: normalize.element({
      dir: state.context.dir,
      ...parts.range.attrs,
      "data-orientation": orientation,
      "data-state": progressState,
      style: {
        [state.context.isHorizontal ? "width" : "height"]: indeterminate ? void 0 : `${percent}%`
      }
    }),
    circleProps: normalize.element({
      dir: state.context.dir,
      id: dom.getCircleId(state.context),
      ...parts.circle.attrs,
      ...progressbarProps,
      ...circleProps.root
    }),
    circleTrackProps: normalize.element({
      dir: state.context.dir,
      "data-orientation": orientation,
      ...parts.circleTrack.attrs,
      ...circleProps.track
    }),
    circleRangeProps: normalize.element({
      dir: state.context.dir,
      ...parts.circleRange.attrs,
      ...circleProps.range,
      "data-state": progressState
    }),
    getIndicatorProps(props) {
      return normalize.element({
        dir: state.context.dir,
        ...parts.indicator.attrs,
        "data-state": props.state,
        hidden: props.state !== progressState
      });
    }
  };
}
function getProgressState(value, maxValue) {
  return value == null ? "indeterminate" : value === maxValue ? "complete" : "loading";
}
function getCircleProps(ctx) {
  const determinant = ctx.isIndeterminate ? void 0 : ctx.percent * 2.64;
  const circleProps = {
    style: {
      cx: "50px",
      cy: "50px",
      r: "42px",
      fill: "transparent",
      strokeWidth: "var(--thickness)"
    }
  };
  return {
    root: {
      viewBox: "0 0 100 100",
      style: {
        width: "var(--size)",
        height: "var(--size)"
      }
    },
    track: circleProps,
    range: {
      style: {
        ...circleProps.style,
        strokeDashoffset: "66px",
        strokeDasharray: determinant != null ? `${determinant} ${264 - determinant}` : void 0
      }
    }
  };
}

// src/progress.machine.ts
import { createMachine } from "@zag-js/core";
import { compact, isNumber } from "@zag-js/utils";
function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "progress",
      initial: "idle",
      context: {
        value: 50,
        max: 100,
        min: 0,
        orientation: "horizontal",
        translations: {
          value: ({ percent }) => percent === -1 ? "loading..." : `${percent} percent`,
          ...ctx.translations
        },
        ...ctx
      },
      created: ["validateContext"],
      computed: {
        isIndeterminate: (ctx2) => ctx2.value === null,
        percent(ctx2) {
          if (!isNumber(ctx2.value))
            return -1;
          return Math.round((ctx2.value - ctx2.min) / (ctx2.max - ctx2.min) * 100);
        },
        isAtMax: (ctx2) => ctx2.value === ctx2.max,
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal",
        isRtl: (ctx2) => ctx2.dir === "rtl"
      },
      states: {
        idle: {
          on: {
            "VALUE.SET": {
              actions: ["setValue"]
            }
          }
        }
      }
    },
    {
      guards: {},
      actions: {
        setValue: (ctx2, evt) => {
          ctx2.value = evt.value === null ? null : Math.max(0, Math.min(evt.value, ctx2.max));
        },
        validateContext: (ctx2) => {
          if (!isValidMaxNumber(ctx2.max)) {
            throw new Error(`[Progress] Invalid max value: ${ctx2.max}`);
          }
          if (!isValidValueNumber(ctx2.value, ctx2.max)) {
            throw new Error(`[Progress] Invalid value: ${ctx2.value}`);
          }
        }
      }
    }
  );
}
function isValidMaxNumber(max) {
  return isNumber(max) && !isNaN(max) && max > 0;
}
function isValidValueNumber(value, max) {
  return isNumber(value) && !isNaN(value) && value <= max && value >= 0;
}
export {
  anatomy,
  connect,
  machine
};
//# sourceMappingURL=index.mjs.map