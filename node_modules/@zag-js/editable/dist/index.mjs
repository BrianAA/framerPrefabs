// src/editable.anatomy.ts
import { createAnatomy } from "@zag-js/anatomy";
var anatomy = createAnatomy("editable").parts(
  "root",
  "area",
  "label",
  "preview",
  "input",
  "editTrigger",
  "submitTrigger",
  "cancelTrigger",
  "control"
);
var parts = anatomy.build();

// src/editable.connect.ts
import { ariaAttr, dataAttr } from "@zag-js/dom-query";

// src/editable.dom.ts
import { createScope } from "@zag-js/dom-query";
var dom = createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `editable:${ctx.id}`,
  getAreaId: (ctx) => ctx.ids?.area ?? `editable:${ctx.id}:area`,
  getLabelId: (ctx) => ctx.ids?.label ?? `editable:${ctx.id}:label`,
  getPreviewId: (ctx) => ctx.ids?.preview ?? `editable:${ctx.id}:preview`,
  getInputId: (ctx) => ctx.ids?.input ?? `editable:${ctx.id}:input`,
  getControlId: (ctx) => ctx.ids?.controls ?? `editable:${ctx.id}:controls`,
  getSubmitTriggerId: (ctx) => ctx.ids?.submitTrigger ?? `editable:${ctx.id}:submit`,
  getCancelTriggerId: (ctx) => ctx.ids?.cancelTrigger ?? `editable:${ctx.id}:cancel`,
  getEditTriggerId: (ctx) => ctx.ids?.editTrigger ?? `editable:${ctx.id}:edit`,
  getInputEl: (ctx) => dom.getById(ctx, dom.getInputId(ctx)),
  getPreviewEl: (ctx) => dom.getById(ctx, dom.getPreviewId(ctx)),
  getSubmitTriggerEl: (ctx) => dom.getById(ctx, dom.getSubmitTriggerId(ctx)),
  getCancelTriggerEl: (ctx) => dom.getById(ctx, dom.getCancelTriggerId(ctx)),
  getEditTriggerEl: (ctx) => dom.getById(ctx, dom.getEditTriggerId(ctx))
});

// src/editable.connect.ts
function connect(state, send, normalize) {
  const isDisabled = state.context.disabled;
  const isInteractive = state.context.isInteractive;
  const isReadOnly = state.context.readOnly;
  const isValueEmpty = state.context.isValueEmpty;
  const isInvalid = state.context.invalid;
  const autoResize = state.context.autoResize;
  const translations = state.context.translations;
  const isEditing = state.matches("edit");
  const placeholderProp = state.context.placeholder;
  const placeholder = typeof placeholderProp === "string" ? { edit: placeholderProp, preview: placeholderProp } : placeholderProp;
  return {
    isEditing,
    isValueEmpty,
    value: state.context.value,
    setValue(value) {
      send({ type: "SET_VALUE", value });
    },
    clearValue() {
      send({ type: "SET_VALUE", value: "" });
    },
    edit() {
      if (!isInteractive)
        return;
      send("EDIT");
    },
    cancel() {
      if (!isInteractive)
        return;
      send("CANCEL");
    },
    submit() {
      if (!isInteractive)
        return;
      send("SUBMIT");
    },
    rootProps: normalize.element({
      ...parts.root.attrs,
      id: dom.getRootId(state.context),
      dir: state.context.dir
    }),
    areaProps: normalize.element({
      ...parts.area.attrs,
      id: dom.getAreaId(state.context),
      dir: state.context.dir,
      style: autoResize ? { display: "inline-grid" } : void 0,
      "data-focus": dataAttr(isEditing),
      "data-disabled": dataAttr(isDisabled),
      "data-placeholder-shown": dataAttr(isValueEmpty)
    }),
    labelProps: normalize.label({
      ...parts.label.attrs,
      id: dom.getLabelId(state.context),
      dir: state.context.dir,
      htmlFor: dom.getInputId(state.context),
      "data-focus": dataAttr(isEditing),
      "data-invalid": dataAttr(isInvalid),
      onPointerDown(event) {
        if (!isEditing) {
          event.preventDefault();
          dom.getPreviewEl(state.context)?.focus();
        }
      }
    }),
    inputProps: normalize.input({
      ...parts.input.attrs,
      dir: state.context.dir,
      "aria-label": translations.input,
      name: state.context.name,
      form: state.context.form,
      id: dom.getInputId(state.context),
      hidden: autoResize ? void 0 : !isEditing,
      placeholder: placeholder?.edit,
      disabled: isDisabled,
      "data-disabled": dataAttr(isDisabled),
      readOnly: isReadOnly,
      "data-readonly": dataAttr(isReadOnly),
      "aria-invalid": ariaAttr(isInvalid),
      "data-invalid": dataAttr(isInvalid),
      defaultValue: state.context.value,
      size: autoResize ? 1 : void 0,
      onChange(event) {
        send({ type: "TYPE", value: event.currentTarget.value });
      },
      onKeyDown(event) {
        const keyMap = {
          Escape() {
            send("CANCEL");
          },
          Enter(event2) {
            if (!event2.shiftKey && !event2.metaKey) {
              send("ENTER");
            }
          }
        };
        const exec = keyMap[event.key];
        if (exec) {
          event.preventDefault();
          exec(event);
        }
      },
      style: autoResize ? {
        all: "unset",
        gridArea: "1 / 1 / auto / auto",
        visibility: !isEditing ? "hidden" : void 0
      } : void 0
    }),
    previewProps: normalize.element({
      id: dom.getPreviewId(state.context),
      ...parts.preview.attrs,
      dir: state.context.dir,
      "data-placeholder-shown": dataAttr(isValueEmpty),
      "aria-readonly": ariaAttr(isReadOnly),
      "data-readonly": dataAttr(isDisabled),
      "data-disabled": dataAttr(isDisabled),
      "aria-disabled": ariaAttr(isDisabled),
      "aria-invalid": ariaAttr(isInvalid),
      "data-invalid": dataAttr(isInvalid),
      children: isValueEmpty ? placeholder?.preview : state.context.value,
      hidden: autoResize ? void 0 : isEditing,
      tabIndex: isInteractive && state.context.isPreviewFocusable ? 0 : void 0,
      onFocus() {
        if (!isInteractive)
          return;
        send("FOCUS");
      },
      onDoubleClick() {
        if (!isInteractive)
          return;
        send("DBLCLICK");
      },
      style: autoResize ? {
        whiteSpace: "pre",
        userSelect: "none",
        gridArea: "1 / 1 / auto / auto",
        visibility: isEditing ? "hidden" : void 0,
        // in event the preview overflow's the parent element
        overflow: "hidden",
        textOverflow: "ellipsis"
      } : void 0
    }),
    editTriggerProps: normalize.button({
      ...parts.editTrigger.attrs,
      id: dom.getEditTriggerId(state.context),
      dir: state.context.dir,
      "aria-label": translations.edit,
      hidden: isEditing,
      type: "button",
      disabled: isDisabled,
      onClick() {
        if (!isInteractive)
          return;
        send("EDIT");
      }
    }),
    controlProps: normalize.element({
      id: dom.getControlId(state.context),
      ...parts.control.attrs,
      dir: state.context.dir
    }),
    submitTriggerProps: normalize.button({
      ...parts.submitTrigger.attrs,
      dir: state.context.dir,
      id: dom.getSubmitTriggerId(state.context),
      "aria-label": translations.submit,
      hidden: !isEditing,
      disabled: isDisabled,
      type: "button",
      onClick() {
        if (!isInteractive)
          return;
        send("SUBMIT");
      }
    }),
    cancelTriggerProps: normalize.button({
      ...parts.cancelTrigger.attrs,
      dir: state.context.dir,
      "aria-label": translations.cancel,
      id: dom.getCancelTriggerId(state.context),
      hidden: !isEditing,
      type: "button",
      disabled: isDisabled,
      onClick() {
        if (!isInteractive)
          return;
        send("CANCEL");
      }
    })
  };
}

// src/editable.machine.ts
import { createMachine, guards } from "@zag-js/core";
import { contains, raf } from "@zag-js/dom-query";
import { trackInteractOutside } from "@zag-js/interact-outside";
import { compact, isEqual } from "@zag-js/utils";
var { not } = guards;
function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "editable",
      initial: ctx.startWithEditView ? "edit" : "preview",
      entry: ctx.startWithEditView ? ["focusInput"] : void 0,
      context: {
        activationMode: "focus",
        submitMode: "both",
        value: "",
        previousValue: "",
        selectOnFocus: true,
        ...ctx,
        translations: {
          input: "editable input",
          edit: "edit",
          submit: "submit",
          cancel: "cancel",
          ...ctx.translations
        }
      },
      watch: {
        value: ["syncInputValue"]
      },
      computed: {
        submitOnEnter: (ctx2) => ["both", "enter"].includes(ctx2.submitMode),
        submitOnBlur: (ctx2) => ["both", "blur"].includes(ctx2.submitMode),
        isInteractive: (ctx2) => !(ctx2.disabled || ctx2.readOnly),
        isValueEmpty: (ctx2) => ctx2.value === "",
        isPreviewFocusable: (ctx2) => ctx2.activationMode === "focus"
      },
      on: {
        SET_VALUE: {
          actions: "setValue"
        }
      },
      states: {
        preview: {
          // // https://bugzilla.mozilla.org/show_bug.cgi?id=559561
          entry: ["blurInputIfNeeded"],
          on: {
            EDIT: {
              target: "edit",
              actions: ["focusInput", "invokeOnEdit"]
            },
            DBLCLICK: {
              guard: "activateOnDblClick",
              target: "edit",
              actions: ["focusInput", "invokeOnEdit"]
            },
            FOCUS: {
              guard: "activateOnFocus",
              target: "edit",
              actions: ["setPreviousValue", "focusInput", "invokeOnEdit"]
            }
          }
        },
        edit: {
          activities: ["trackInteractOutside"],
          on: {
            TYPE: {
              guard: not("isAtMaxLength"),
              actions: "setValue"
            },
            BLUR: [
              {
                guard: "submitOnBlur",
                target: "preview",
                actions: ["restoreFocus", "invokeOnSubmit"]
              },
              {
                target: "preview",
                actions: ["revertValue", "restoreFocus", "invokeOnCancel"]
              }
            ],
            CANCEL: {
              target: "preview",
              actions: ["revertValue", "restoreFocus", "invokeOnCancel"]
            },
            ENTER: {
              guard: "submitOnEnter",
              target: "preview",
              actions: ["setPreviousValue", "invokeOnSubmit", "restoreFocus"]
            },
            SUBMIT: {
              target: "preview",
              actions: ["setPreviousValue", "invokeOnSubmit", "restoreFocus"]
            }
          }
        }
      }
    },
    {
      guards: {
        submitOnBlur: (ctx2) => ctx2.submitOnBlur,
        submitOnEnter: (ctx2) => ctx2.submitOnEnter,
        isAtMaxLength: (ctx2) => ctx2.maxLength != null && ctx2.value.length === ctx2.maxLength,
        activateOnDblClick: (ctx2) => ctx2.activationMode === "dblclick",
        activateOnFocus: (ctx2) => ctx2.activationMode === "focus"
      },
      activities: {
        trackInteractOutside(ctx2, _evt, { send }) {
          return trackInteractOutside(dom.getInputEl(ctx2), {
            exclude(target) {
              const ignore = [dom.getCancelTriggerEl(ctx2), dom.getSubmitTriggerEl(ctx2)];
              return ignore.some((el) => contains(el, target));
            },
            onFocusOutside: ctx2.onFocusOutside,
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onInteractOutside(event) {
              ctx2.onInteractOutside?.(event);
              if (event.defaultPrevented)
                return;
              const { focusable } = event.detail;
              send({ type: "BLUR", src: "interact-outside", focusable });
            }
          });
        }
      },
      actions: {
        restoreFocus(ctx2, evt) {
          if (evt.focusable)
            return;
          raf(() => {
            const finalEl = ctx2.finalFocusEl?.() ?? dom.getEditTriggerEl(ctx2);
            finalEl?.focus({ preventScroll: true });
          });
        },
        focusInput(ctx2) {
          raf(() => {
            const inputEl = dom.getInputEl(ctx2);
            if (!inputEl)
              return;
            if (ctx2.selectOnFocus) {
              inputEl.select();
            } else {
              inputEl.focus({ preventScroll: true });
            }
          });
        },
        invokeOnCancel(ctx2) {
          ctx2.onValueRevert?.({ value: ctx2.previousValue });
        },
        invokeOnSubmit(ctx2) {
          ctx2.onValueCommit?.({ value: ctx2.value });
        },
        invokeOnEdit(ctx2) {
          ctx2.onEdit?.();
        },
        syncInputValue(ctx2) {
          sync.value(ctx2);
        },
        setValue(ctx2, evt) {
          set.value(ctx2, evt.value);
        },
        setPreviousValue(ctx2) {
          ctx2.previousValue = ctx2.value;
        },
        revertValue(ctx2) {
          set.value(ctx2, ctx2.previousValue);
        },
        blurInputIfNeeded(ctx2) {
          dom.getInputEl(ctx2)?.blur();
        }
      }
    }
  );
}
var sync = {
  value: (ctx) => {
    const inputEl = dom.getInputEl(ctx);
    dom.setValue(inputEl, ctx.value);
  }
};
var invoke = {
  change(ctx) {
    ctx.onValueChange?.({ value: ctx.value });
    sync.value(ctx);
  }
};
var set = {
  value(ctx, value) {
    if (isEqual(ctx.value, value))
      return;
    ctx.value = value;
    invoke.change(ctx);
  }
};
export {
  anatomy,
  connect,
  machine
};
//# sourceMappingURL=index.mjs.map