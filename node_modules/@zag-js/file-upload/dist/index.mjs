// src/file-upload.anatomy.ts
import { createAnatomy } from "@zag-js/anatomy";
var anatomy = createAnatomy("file-upload").parts(
  "root",
  "dropzone",
  "item",
  "itemDeleteTrigger",
  "itemGroup",
  "itemName",
  "itemPreview",
  "itemPreviewImage",
  "itemSizeText",
  "label",
  "trigger"
);
var parts = anatomy.build();

// src/file-upload.connect.ts
import { contains, dataAttr, isSelfEvent } from "@zag-js/dom-query";
import { formatFileSize } from "@zag-js/file-utils";
import "@zag-js/types";
import { visuallyHiddenStyle } from "@zag-js/visually-hidden";

// src/file-upload.dom.ts
import { createScope } from "@zag-js/dom-query";
var dom = createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `file:${ctx.id}`,
  getDropzoneId: (ctx) => ctx.ids?.dropzone ?? `file:${ctx.id}:dropzone`,
  getHiddenInputId: (ctx) => ctx.ids?.hiddenInput ?? `file:${ctx.id}:input`,
  getTriggerId: (ctx) => ctx.ids?.trigger ?? `file:${ctx.id}:trigger`,
  getLabelId: (ctx) => ctx.ids?.label ?? `file:${ctx.id}:label`,
  getItemId: (ctx, id) => ctx.ids?.item?.(id) ?? `file:${ctx.id}:item:${id}`,
  getItemNameId: (ctx, id) => ctx.ids?.itemName?.(id) ?? `file:${ctx.id}:item-name:${id}`,
  getItemSizeTextId: (ctx, id) => ctx.ids?.itemSizeText?.(id) ?? `file:${ctx.id}:item-size:${id}`,
  getItemPreviewId: (ctx, id) => ctx.ids?.itemPreview?.(id) ?? `file:${ctx.id}:item-preview:${id}`,
  getHiddenInputEl: (ctx) => dom.getById(ctx, dom.getHiddenInputId(ctx)),
  getDropzoneEl: (ctx) => dom.getById(ctx, dom.getDropzoneId(ctx))
});

// src/file-upload.utils.ts
import { isValidFileSize, isValidFileType } from "@zag-js/file-utils";
function isEventWithFiles(event) {
  if (!event.dataTransfer)
    return !!event.target && "files" in event.target;
  return event.dataTransfer.types.some((type) => {
    return type === "Files" || type === "application/x-moz-file";
  });
}
function isFilesWithinRange(ctx, incomingCount) {
  if (!ctx.multiple && incomingCount > 1)
    return false;
  if (!ctx.multiple && incomingCount + ctx.files.length === 2)
    return true;
  if (incomingCount + ctx.files.length > ctx.maxFiles)
    return false;
  return true;
}
function getFilesFromEvent(ctx, files) {
  const acceptedFiles = [];
  const rejectedFiles = [];
  files.forEach((file) => {
    const [accepted, acceptError] = isValidFileType(file, ctx.acceptAttr);
    const [sizeMatch, sizeError] = isValidFileSize(file, ctx.minFileSize, ctx.maxFileSize);
    const validateErrors = ctx.validate?.(file);
    const valid = validateErrors ? validateErrors.length === 0 : true;
    if (accepted && sizeMatch && valid) {
      acceptedFiles.push(file);
    } else {
      const errors = [acceptError, sizeError];
      if (!valid)
        errors.push(...validateErrors ?? []);
      rejectedFiles.push({ file, errors: errors.filter(Boolean) });
    }
  });
  if (!isFilesWithinRange(ctx, acceptedFiles.length)) {
    acceptedFiles.forEach((file) => {
      rejectedFiles.push({ file, errors: ["TOO_MANY_FILES"] });
    });
    acceptedFiles.splice(0);
  }
  return {
    acceptedFiles,
    rejectedFiles
  };
}

// src/file-upload.connect.ts
function connect(state, send, normalize) {
  const disabled = state.context.disabled;
  const allowDrop = state.context.allowDrop;
  const translations = state.context.translations;
  const isDragging = state.matches("dragging");
  const isFocused = state.matches("focused") && !disabled;
  return {
    isDragging,
    isFocused,
    open() {
      send("OPEN");
    },
    deleteFile(file) {
      send({ type: "FILE.DELETE", file });
    },
    files: state.context.files,
    setFiles(files) {
      const count = files.length;
      send({ type: "FILES.SET", files, count });
    },
    clearFiles() {
      send({ type: "FILES.CLEAR" });
    },
    getFileSize(file) {
      return formatFileSize(file.size, { locale: state.context.locale });
    },
    createFileUrl(file, cb) {
      const win = dom.getWin(state.context);
      const url = win.URL.createObjectURL(file);
      cb(url);
      return () => win.URL.revokeObjectURL(url);
    },
    rootProps: normalize.element({
      ...parts.root.attrs,
      dir: state.context.dir,
      id: dom.getRootId(state.context),
      "data-disabled": dataAttr(disabled),
      "data-dragging": dataAttr(isDragging)
    }),
    dropzoneProps: normalize.element({
      ...parts.dropzone.attrs,
      dir: state.context.dir,
      id: dom.getDropzoneId(state.context),
      tabIndex: disabled ? void 0 : 0,
      "aria-disabled": disabled,
      "aria-invalid": state.context.invalid,
      "data-invalid": dataAttr(state.context.invalid),
      "data-disabled": dataAttr(disabled),
      "data-dragging": dataAttr(isDragging),
      onKeyDown(event) {
        if (!isSelfEvent(event))
          return;
        if (event.key !== "Enter" && event.key !== " ")
          return;
        send({ type: "DROPZONE.CLICK", src: "keydown" });
      },
      onClick(event) {
        const isLabel = event.currentTarget.localName === "label";
        if (isLabel)
          event.preventDefault();
        send("DROPZONE.CLICK");
      },
      onDragOver(event) {
        if (!allowDrop)
          return;
        event.preventDefault();
        event.stopPropagation();
        try {
          event.dataTransfer.dropEffect = "copy";
        } catch {
        }
        const hasFiles = isEventWithFiles(event);
        if (!hasFiles)
          return;
        const count = event.dataTransfer.items.length;
        send({ type: "DROPZONE.DRAG_OVER", count });
      },
      onDragLeave(event) {
        if (!allowDrop || disabled)
          return;
        if (contains(event.currentTarget, event.relatedTarget))
          return;
        send({ type: "DROPZONE.DRAG_LEAVE" });
      },
      onDrop(event) {
        if (allowDrop) {
          event.preventDefault();
          event.stopPropagation();
        }
        const hasFiles = isEventWithFiles(event);
        if (disabled || !hasFiles)
          return;
        send({ type: "DROPZONE.DROP", files: Array.from(event.dataTransfer.files) });
      },
      onFocus() {
        send("DROPZONE.FOCUS");
      },
      onBlur() {
        send("DROPZONE.BLUR");
      }
    }),
    triggerProps: normalize.button({
      ...parts.trigger.attrs,
      dir: state.context.dir,
      id: dom.getTriggerId(state.context),
      disabled,
      "data-disabled": dataAttr(disabled),
      type: "button",
      onClick(event) {
        if (disabled)
          return;
        if (contains(dom.getDropzoneEl(state.context), event.currentTarget)) {
          event.stopPropagation();
        }
        send("OPEN");
      }
    }),
    hiddenInputProps: normalize.input({
      id: dom.getHiddenInputId(state.context),
      tabIndex: -1,
      disabled,
      type: "file",
      name: state.context.name,
      accept: state.context.acceptAttr,
      multiple: state.context.multiple || state.context.maxFiles > 1,
      onClick(event) {
        event.stopPropagation();
        event.currentTarget.value = "";
      },
      onChange(event) {
        if (disabled)
          return;
        const { files } = event.currentTarget;
        send({ type: "FILES.SET", files: files ? Array.from(files) : [] });
      },
      style: visuallyHiddenStyle
    }),
    itemGroupProps: normalize.element({
      ...parts.itemGroup.attrs,
      dir: state.context.dir,
      "data-disabled": dataAttr(disabled)
    }),
    getItemProps(props) {
      const { file } = props;
      return normalize.element({
        ...parts.item.attrs,
        dir: state.context.dir,
        id: dom.getItemId(state.context, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemNameProps(props) {
      const { file } = props;
      return normalize.element({
        ...parts.itemName.attrs,
        dir: state.context.dir,
        id: dom.getItemNameId(state.context, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemSizeTextProps(props) {
      const { file } = props;
      return normalize.element({
        ...parts.itemSizeText.attrs,
        dir: state.context.dir,
        id: dom.getItemSizeTextId(state.context, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemPreviewProps(props) {
      const { file } = props;
      return normalize.element({
        ...parts.itemPreview.attrs,
        dir: state.context.dir,
        id: dom.getItemPreviewId(state.context, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemPreviewImageProps(props) {
      const { file, url } = props;
      const isImage = file.type.startsWith("image/");
      if (!isImage) {
        throw new Error("Preview Image is only supported for image files");
      }
      return normalize.img({
        ...parts.itemPreviewImage.attrs,
        alt: translations.itemPreview(file),
        src: url,
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemDeleteTriggerProps(props) {
      const { file } = props;
      return normalize.button({
        ...parts.itemDeleteTrigger.attrs,
        dir: state.context.dir,
        type: "button",
        disabled,
        "data-disabled": dataAttr(disabled),
        "aria-label": translations.deleteFile(file),
        onClick() {
          if (disabled)
            return;
          send({ type: "FILE.DELETE", file });
        }
      });
    },
    labelProps: normalize.label({
      ...parts.label.attrs,
      dir: state.context.dir,
      id: dom.getLabelId(state.context),
      htmlFor: dom.getHiddenInputId(state.context),
      "data-disabled": dataAttr(disabled)
    })
  };
}

// src/file-upload.machine.ts
import { createMachine, guards, ref } from "@zag-js/core";
import { raf } from "@zag-js/dom-query";
import { getAcceptAttrString, isFileEqual } from "@zag-js/file-utils";
import { compact } from "@zag-js/utils";
var { not } = guards;
function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "fileupload",
      initial: "idle",
      context: {
        minFileSize: 0,
        maxFileSize: Infinity,
        maxFiles: 1,
        allowDrop: true,
        ...ctx,
        files: ref(ctx.files ?? []),
        rejectedFiles: ref([]),
        invalid: false,
        translations: {
          itemPreview: (file) => `preview of ${file.name}`,
          deleteFile: (file) => `delete file ${file.name}`,
          ...ctx.translations
        }
      },
      computed: {
        acceptAttr: (ctx2) => getAcceptAttrString(ctx2.accept),
        multiple: (ctx2) => ctx2.maxFiles > 1
      },
      on: {
        "FILES.SET": {
          actions: ["setFilesFromEvent"]
        },
        "FILE.DELETE": {
          actions: ["removeFile"]
        },
        "FILES.CLEAR": {
          actions: ["clearFiles"]
        }
      },
      states: {
        idle: {
          on: {
            OPEN: {
              actions: ["openFilePicker"]
            },
            "DROPZONE.CLICK": {
              actions: ["openFilePicker"]
            },
            "DROPZONE.FOCUS": "focused",
            "DROPZONE.DRAG_OVER": [
              {
                guard: not("isWithinRange"),
                target: "dragging",
                actions: ["setInvalid"]
              },
              { target: "dragging" }
            ]
          }
        },
        focused: {
          on: {
            "DROPZONE.BLUR": "idle",
            OPEN: {
              actions: ["openFilePicker"]
            },
            "DROPZONE.CLICK": {
              actions: ["openFilePicker"]
            },
            "DROPZONE.DRAG_OVER": [
              {
                guard: not("isWithinRange"),
                target: "dragging",
                actions: ["setInvalid"]
              },
              { target: "dragging" }
            ]
          }
        },
        dragging: {
          on: {
            "DROPZONE.DROP": {
              target: "idle",
              actions: ["clearInvalid", "setFilesFromEvent"]
            },
            "DROPZONE.DRAG_LEAVE": {
              target: "idle",
              actions: ["clearInvalid"]
            }
          }
        }
      }
    },
    {
      guards: {
        isWithinRange: (ctx2, evt) => isFilesWithinRange(ctx2, evt.count)
      },
      actions: {
        openFilePicker(ctx2) {
          raf(() => {
            dom.getHiddenInputEl(ctx2)?.click();
          });
        },
        setInvalid(ctx2) {
          ctx2.invalid = true;
        },
        clearInvalid(ctx2) {
          ctx2.invalid = false;
        },
        setFilesFromEvent(ctx2, evt) {
          const result = getFilesFromEvent(ctx2, evt.files);
          const { acceptedFiles, rejectedFiles } = result;
          if (ctx2.multiple) {
            const files = ref([...ctx2.files, ...acceptedFiles]);
            set.files(ctx2, files, rejectedFiles);
            return;
          }
          if (acceptedFiles.length) {
            const files = ref([acceptedFiles[0]]);
            set.files(ctx2, files, rejectedFiles);
          }
        },
        removeFile(ctx2, evt) {
          const nextFiles = ctx2.files.filter((file) => file !== evt.file);
          set.files(ctx2, nextFiles);
        },
        clearFiles(ctx2) {
          set.files(ctx2, []);
        }
      },
      compareFns: {
        files: (a, b) => a.length === b.length && a.every((file, i) => isFileEqual(file, b[i]))
      }
    }
  );
}
var invoke = {
  change: (ctx) => {
    ctx.onFilesChange?.({
      acceptedFiles: ctx.files,
      rejectedFiles: ctx.rejectedFiles
    });
  },
  accept: (ctx) => {
    ctx.onFileAccept?.({ files: ctx.files });
  },
  reject: (ctx) => {
    ctx.onFileReject?.({ files: ctx.rejectedFiles });
  }
};
var set = {
  files: (ctx, acceptedFiles, rejectedFiles) => {
    ctx.files = ref(acceptedFiles);
    invoke.accept(ctx);
    if (rejectedFiles) {
      ctx.rejectedFiles = ref(rejectedFiles);
      invoke.reject(ctx);
    }
    invoke.change(ctx);
  }
};
export {
  anatomy,
  connect,
  machine
};
//# sourceMappingURL=index.mjs.map