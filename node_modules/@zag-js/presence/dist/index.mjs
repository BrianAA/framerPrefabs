// src/presence.connect.ts
function connect(state, send, normalize) {
  return {
    isPresent: state.matches("mounted", "unmountSuspended"),
    setNode(node) {
      if (!node)
        return;
      send({ type: "NODE.SET", node });
    }
  };
}

// src/presence.machine.ts
import { createMachine, ref, guards } from "@zag-js/core";
var { and, or } = guards;
function getAnimationName(styles) {
  return styles?.animationName || "none";
}
function machine(ctx) {
  const initialState = ctx.present ? "mounted" : "unmounted";
  return createMachine(
    {
      initial: initialState,
      watch: {
        present: ["raisePresenceChange", "setPrevPresent"]
      },
      context: {
        node: null,
        styles: null,
        prevAnimationName: "",
        present: false,
        ...ctx
      },
      on: {
        "NODE.SET": {
          actions: ["setNode", "setStyles"]
        },
        "PRESENCE.CHANGED": [
          {
            guard: "isPresent",
            target: "mounted",
            actions: ["setPrevAnimationName"]
          },
          {
            guard: or("isAnimationNone", "isDisplayNone"),
            target: "unmounted"
          },
          {
            guard: and("wasPresent", "isAnimating"),
            target: "unmountSuspended"
          },
          { target: "unmounted" }
        ]
      },
      states: {
        mounted: {
          on: {
            UNMOUNT: "unmounted",
            "ANIMATION.OUT": "unmountSuspended"
          }
        },
        unmountSuspended: {
          activities: ["trackAnimationEvents"],
          on: {
            MOUNT: {
              target: "mounted",
              actions: ["setPrevAnimationName"]
            },
            "ANIMATION.END": "unmounted"
          }
        },
        unmounted: {
          entry: ["clearPrevAnimationName", "invokeOnExitComplete"],
          on: {
            MOUNT: "mounted"
          }
        }
      }
    },
    {
      guards: {
        isPresent: (ctx2) => !!ctx2.present,
        isAnimationNone: (ctx2) => getAnimationName(ctx2.styles) === "none",
        isDisplayNone: (ctx2) => ctx2.styles?.display === "none",
        wasPresent: (ctx2) => !!ctx2.prevPresent,
        isAnimating: (ctx2) => ctx2.prevAnimationName !== getAnimationName(ctx2.styles)
      },
      actions: {
        invokeOnExitComplete(ctx2) {
          ctx2.onExitComplete?.();
        },
        setNode(ctx2, evt) {
          ctx2.node = ref(evt.node);
        },
        setStyles(ctx2, evt) {
          const win = evt.node.ownerDocument.defaultView || window;
          ctx2.styles = ref(win.getComputedStyle(evt.node));
        },
        raisePresenceChange(_ctx, _evt, { send }) {
          send("PRESENCE.CHANGED");
        },
        setPrevPresent(ctx2) {
          ctx2.prevPresent = ctx2.present;
        },
        setPrevAnimationName(ctx2) {
          requestAnimationFrame(() => {
            ctx2.prevAnimationName = getAnimationName(ctx2.styles);
          });
        },
        clearPrevAnimationName(ctx2) {
          ctx2.prevAnimationName = "";
        }
      },
      activities: {
        trackAnimationEvents(ctx2, _evt, { send }) {
          const node = ctx2.node;
          if (!node)
            return;
          const onStart = (event) => {
            if (event.target === node) {
              ctx2.prevAnimationName = getAnimationName(ctx2.styles);
            }
          };
          const onEnd = (event) => {
            const currentAnimationName = getAnimationName(ctx2.styles);
            const isCurrentAnimation = currentAnimationName.includes(event.animationName);
            if (event.target === node && isCurrentAnimation) {
              send("ANIMATION.END");
            }
          };
          node.addEventListener("animationstart", onStart);
          node.addEventListener("animationcancel", onEnd);
          node.addEventListener("animationend", onEnd);
          return () => {
            node.removeEventListener("animationstart", onStart);
            node.removeEventListener("animationcancel", onEnd);
            node.removeEventListener("animationend", onEnd);
          };
        }
      }
    }
  );
}
export {
  connect,
  machine
};
//# sourceMappingURL=index.mjs.map