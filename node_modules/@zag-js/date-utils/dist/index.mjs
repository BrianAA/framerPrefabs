// src/constrain.ts
import {
  maxDate,
  minDate,
  startOfMonth,
  startOfWeek,
  startOfYear,
  toCalendarDate
} from "@internationalized/date";
function alignCenter(date, duration, locale, min, max) {
  let halfDuration = {};
  for (let key in duration) {
    halfDuration[key] = Math.floor(duration[key] / 2);
    if (halfDuration[key] > 0 && duration[key] % 2 === 0) {
      halfDuration[key]--;
    }
  }
  let aligned = alignStart(date, duration, locale).subtract(halfDuration);
  return constrainStart(date, aligned, duration, locale, min, max);
}
function alignStart(date, duration, locale, min, max) {
  let aligned = date;
  if (duration.years) {
    aligned = startOfYear(date);
  } else if (duration.months) {
    aligned = startOfMonth(date);
  } else if (duration.weeks) {
    aligned = startOfWeek(date, locale);
  }
  return constrainStart(date, aligned, duration, locale, min, max);
}
function alignEnd(date, duration, locale, min, max) {
  let d = { ...duration };
  if (d.days) {
    d.days--;
  } else if (d.weeks) {
    d.weeks--;
  } else if (d.months) {
    d.months--;
  } else if (d.years) {
    d.years--;
  }
  let aligned = alignStart(date, duration, locale).subtract(d);
  return constrainStart(date, aligned, duration, locale, min, max);
}
function constrainStart(date, aligned, duration, locale, min, max) {
  if (min && date.compare(min) >= 0) {
    aligned = maxDate(aligned, alignStart(toCalendarDate(min), duration, locale));
  }
  if (max && date.compare(max) <= 0) {
    aligned = minDate(aligned, alignEnd(toCalendarDate(max), duration, locale));
  }
  return aligned;
}
function constrainValue(date, minValue, maxValue) {
  if (minValue) {
    date = maxDate(date, toCalendarDate(minValue));
  }
  if (maxValue) {
    date = minDate(date, toCalendarDate(maxValue));
  }
  return date;
}

// src/align.ts
function alignDate(date, alignment, duration, locale, min, max) {
  switch (alignment) {
    case "start":
      return alignStart(date, duration, locale, min, max);
    case "end":
      return alignEnd(date, duration, locale, min, max);
    case "center":
    default:
      return alignCenter(date, duration, locale, min, max);
  }
}
function alignStartDate(date, startDate, endDate, duration, locale, min, max) {
  if (date.compare(startDate) < 0) {
    return alignEnd(date, duration, locale, min, max);
  }
  if (date.compare(endDate) > 0) {
    return alignStart(date, duration, locale, min, max);
  }
  return startDate;
}

// src/assertion.ts
import { isSameDay, isToday } from "@internationalized/date";
function isTodayDate(date, timeZone) {
  return isToday(date, timeZone);
}
function isDateEqual(dateA, dateB) {
  return dateB != null && isSameDay(dateA, dateB);
}
function isDateInvalid(date, minValue, maxValue) {
  return minValue != null && date.compare(minValue) < 0 || maxValue != null && date.compare(maxValue) > 0;
}
function isDateDisabled(date, startDate, endDate, minValue, maxValue) {
  return date.compare(startDate) < 0 || date.compare(endDate) > 0 || isDateInvalid(date, minValue, maxValue);
}
function isDateUnavailable(date, isUnavailable, locale, minValue, maxValue) {
  if (!date) {
    return false;
  }
  if (isUnavailable?.(date, locale)) {
    return true;
  }
  return isDateInvalid(date, minValue, maxValue);
}
function isDateOutsideVisibleRange(date, startDate, endDate) {
  return date.compare(startDate) < 0 || date.compare(endDate) > 0;
}
function isPreviousVisibleRangeInvalid(startDate, minValue, maxValue) {
  const prevDate = startDate.subtract({ days: 1 });
  return isSameDay(prevDate, startDate) || isDateInvalid(prevDate, minValue, maxValue);
}
function isNextVisibleRangeInvalid(endDate, minValue, maxValue) {
  const nextDate = endDate.add({ days: 1 });
  return isSameDay(nextDate, endDate) || isDateInvalid(nextDate, minValue, maxValue);
}

// src/duration.ts
function getUnitDuration(duration) {
  let d = { ...duration };
  for (let key in d) {
    d[key] = 1;
  }
  return d;
}
function getEndDate(startDate, duration) {
  let d = { ...duration };
  if (d.days) {
    d.days--;
  } else {
    d.days = -1;
  }
  return startDate.add(d);
}

// src/format-date.ts
import { toCalendarDateTime } from "@internationalized/date";
function createRegEx(sign) {
  let symbols = "\\s|\\.|-|/|\\\\|,|\\$|\\!|\\?|:|;";
  return new RegExp("(^|>|" + symbols + ")(" + sign + ")($|<|" + symbols + ")", "g");
}
function formatDate(value, formatString, locale, timeZone = "UTC") {
  const datetime = toCalendarDateTime(value);
  const date = datetime.toDate(timeZone);
  const formats = {
    // Time in ms
    T: date.getTime(),
    // Minutes
    m: date.toLocaleString(locale, { minute: "numeric" }),
    mm: date.toLocaleString(locale, { minute: "2-digit" }),
    // Seconds
    s: date.toLocaleString(locale, { second: "numeric" }),
    ss: date.toLocaleString(locale, { second: "2-digit" }),
    // Hours
    h: date.toLocaleString(locale, { hour: "numeric", hour12: true }),
    hh: date.toLocaleString(locale, { hour: "2-digit", hour12: true }),
    H: date.toLocaleString(locale, { hour: "numeric", hour12: false }),
    HH: date.toLocaleString(locale, { hour: "2-digit", hour12: false }),
    // Day period
    aa: date.toLocaleString(locale, { hour: "numeric", hour12: true }).toLowerCase(),
    AA: date.toLocaleString(locale, { hour: "numeric", hour12: true }).toUpperCase(),
    // Day of week
    E: date.toLocaleString(locale, { weekday: "short" }),
    EE: date.toLocaleString(locale, { weekday: "short" }),
    EEE: date.toLocaleString(locale, { weekday: "short" }),
    EEEE: date.toLocaleString(locale, { weekday: "long" }),
    // Date of month
    d: datetime.day,
    dd: date.toLocaleString(locale, { day: "2-digit" }),
    // Months
    M: datetime.month + 1,
    MM: date.toLocaleString(locale, { month: "2-digit" }),
    MMM: date.toLocaleString(locale, { month: "short" }),
    MMMM: date.toLocaleString(locale, { month: "long" }),
    // Years
    yy: date.toLocaleString(locale, { year: "2-digit" }),
    yyyy: date.toLocaleString(locale, { year: "numeric" }),
    YY: date.toLocaleString(locale, { year: "2-digit" }),
    YYYY: date.toLocaleString(locale, { year: "numeric" })
  };
  let result = formatString;
  for (const key in formats) {
    result = result.replace(createRegEx(key), "$1" + formats[key] + "$3");
  }
  return result;
}

// src/format-range.ts
function formatRange(startDate, endDate, formatter, toString, timeZone) {
  let parts = formatter.formatRangeToParts(startDate.toDate(timeZone), endDate.toDate(timeZone));
  let separatorIndex = -1;
  for (let i = 0; i < parts.length; i++) {
    let part = parts[i];
    if (part.source === "shared" && part.type === "literal") {
      separatorIndex = i;
    } else if (part.source === "endRange") {
      break;
    }
  }
  let start = "";
  let end = "";
  for (let i = 0; i < parts.length; i++) {
    if (i < separatorIndex) {
      start += parts[i].value;
    } else if (i > separatorIndex) {
      end += parts[i].value;
    }
  }
  return toString(start, end);
}

// src/format-selected-date.ts
import { isSameDay as isSameDay2 } from "@internationalized/date";

// src/get-day-formatter.ts
import { DateFormatter, toCalendarDateTime as toCalendarDateTime2, today } from "@internationalized/date";

// src/get-era-format.ts
function getEraFormat(date) {
  return date?.calendar.identifier === "gregory" && date.era === "BC" ? "short" : void 0;
}

// src/get-day-formatter.ts
function getDayFormatter(locale, timeZone) {
  const date = toCalendarDateTime2(today(timeZone));
  return new DateFormatter(locale, {
    weekday: "long",
    month: "long",
    year: "numeric",
    day: "numeric",
    era: getEraFormat(date),
    timeZone
  });
}

// src/format-selected-date.ts
function formatSelectedDate(startDate, endDate, locale, timeZone) {
  let start = startDate;
  let end = endDate ?? startDate;
  let formatter = getDayFormatter(locale, timeZone);
  if (isSameDay2(start, end)) {
    return formatter.format(start.toDate(timeZone));
  }
  return formatRange(start, end, formatter, (start2, end2) => `${start2} \u2013 ${end2}`, timeZone);
}

// src/format-visible-range.ts
import { endOfMonth, isSameDay as isSameDay3, startOfMonth as startOfMonth2 } from "@internationalized/date";

// src/get-month-formatter.ts
import { today as today2, toCalendarDate as toCalendarDate2, DateFormatter as DateFormatter2 } from "@internationalized/date";
function getMonthFormatter(locale, timeZone) {
  const date = toCalendarDate2(today2(timeZone));
  return new DateFormatter2(locale, {
    month: "long",
    year: "numeric",
    era: getEraFormat(date),
    calendar: date?.calendar.identifier,
    timeZone
  });
}

// src/format-visible-range.ts
function formatVisibleRange(startDate, endDate, locale, timeZone) {
  const start = startDate;
  const end = endDate ?? startDate;
  const dayFormatter = getDayFormatter(locale, timeZone);
  if (!isSameDay3(start, startOfMonth2(start))) {
    return dayFormatter.formatRange(start.toDate(timeZone), end.toDate(timeZone));
  }
  const monthFormatter = getMonthFormatter(locale, timeZone);
  if (isSameDay3(end, endOfMonth(start))) {
    return monthFormatter.format(start.toDate(timeZone));
  }
  if (isSameDay3(end, endOfMonth(end))) {
    return monthFormatter.formatRange(start.toDate(timeZone), end.toDate(timeZone));
  }
  return "";
}

// src/get-decade-range.ts
function getDecadeRange(year) {
  const computedYear = year - year % 10 - 1;
  const years = [];
  for (let i = 0; i < 12; i += 1) {
    const value = computedYear + i;
    years.push(value);
  }
  return years;
}

// src/get-month-days.ts
import { getWeeksInMonth, isSameDay as isSameDay4 } from "@internationalized/date";

// src/get-start-of-week.ts
import { getDayOfWeek } from "@internationalized/date";
function getStartOfWeek(date, locale, firstDayOfWeek = 0) {
  const day = getDayOfWeek(date, locale);
  const diff = (day - firstDayOfWeek + 7) % 7;
  return date.subtract({ days: diff });
}

// src/get-month-days.ts
function getDaysInWeek(weekIndex, from, locale, firstDayOfWeek) {
  const weekDate = from.add({ weeks: weekIndex });
  const dates = [];
  let date = getStartOfWeek(weekDate, locale, firstDayOfWeek);
  while (dates.length < 7) {
    dates.push(date);
    let nextDate = date.add({ days: 1 });
    if (isSameDay4(date, nextDate)) {
      break;
    }
    date = nextDate;
  }
  return dates;
}
function getMonthDays(from, locale, numOfWeeks, firstDayOfWeek) {
  const monthWeeks = getWeeksInMonth(from, locale);
  const weeks = [...new Array(numOfWeeks ?? monthWeeks).keys()];
  return weeks.map((week) => getDaysInWeek(week, from, locale, firstDayOfWeek));
}

// src/get-month-names.ts
function getMonthNames(locale, format = "long") {
  const date = new Date(2021, 0, 1);
  const monthNames = [];
  for (let i = 0; i < 12; i++) {
    monthNames.push(date.toLocaleString(locale, { month: format }));
    date.setMonth(date.getMonth() + 1);
  }
  return monthNames;
}

// src/get-weekday-formats.ts
import { DateFormatter as DateFormatter3 } from "@internationalized/date";
function getWeekdayFormats(locale, timeZone) {
  const longFormat = new DateFormatter3(locale, { weekday: "long", timeZone });
  const shortFormat = new DateFormatter3(locale, { weekday: "short", timeZone });
  const narrowFormat = new DateFormatter3(locale, { weekday: "narrow", timeZone });
  return (value) => {
    const date = value instanceof Date ? value : value.toDate(timeZone);
    return {
      value,
      short: shortFormat.format(date),
      long: longFormat.format(date),
      narrow: narrowFormat.format(date)
    };
  };
}

// src/get-week-days.ts
function getWeekDays(date, startOfWeekProp, timeZone, locale) {
  const firstDayOfWeek = getStartOfWeek(date, locale, startOfWeekProp);
  const weeks = [...new Array(7).keys()];
  const format = getWeekdayFormats(locale, timeZone);
  return weeks.map((index) => format(firstDayOfWeek.add({ days: index })));
}

// src/get-year-range.ts
function getYearsRange(range) {
  const years = [];
  for (let year = range.from; year <= range.to; year += 1) {
    years.push(year);
  }
  return years;
}

// src/mutation.ts
import {
  getLocalTimeZone,
  toCalendar,
  toCalendarDateTime as toCalendarDateTime3,
  today as today3
} from "@internationalized/date";
function getTodayDate(timeZone) {
  return today3(timeZone ?? getLocalTimeZone());
}
function getNextDay(date) {
  return date.add({ days: 1 });
}
function getPreviousDay(date) {
  return date.subtract({ days: 1 });
}
function setMonth(date, month) {
  return date.set({ month });
}
function setYear(date, year) {
  return date.set({ year });
}
function setCalendar(date, calendar) {
  return toCalendar(toCalendarDateTime3(date), calendar);
}
function setDate(date, startDate, isDateUnavailable2, locale, minValue, maxValue) {
  let result;
  result = constrainValue(date, minValue, maxValue);
  result = getPreviousAvailableDate(date, startDate, locale, isDateUnavailable2);
  return result;
}
function getPreviousAvailableDate(date, minValue, locale, isDateUnavailable2) {
  if (!isDateUnavailable2) {
    return date;
  }
  while (date.compare(minValue) >= 0 && isDateUnavailable2(date, locale)) {
    date = date.subtract({ days: 1 });
  }
  if (date.compare(minValue) >= 0) {
    return date;
  }
}

// src/pagination.ts
import {
  endOfMonth as endOfMonth2,
  endOfWeek,
  startOfMonth as startOfMonth3,
  startOfWeek as startOfWeek2
} from "@internationalized/date";
function getAdjustedDateFn(visibleDuration, locale, minValue, maxValue) {
  return function getDate(options) {
    const { startDate, focusedDate } = options;
    const endDate = getEndDate(startDate, visibleDuration);
    if (isDateInvalid(focusedDate, minValue, maxValue)) {
      return {
        startDate,
        focusedDate: constrainValue(focusedDate, minValue, maxValue),
        endDate
      };
    }
    if (focusedDate.compare(startDate) < 0) {
      return {
        startDate: alignEnd(focusedDate, visibleDuration, locale, minValue, maxValue),
        endDate,
        focusedDate: constrainValue(focusedDate, minValue, maxValue)
      };
    }
    if (focusedDate.compare(endDate) > 0) {
      return {
        startDate: alignStart(focusedDate, visibleDuration, locale, minValue, maxValue),
        endDate,
        focusedDate: constrainValue(focusedDate, minValue, maxValue)
      };
    }
    return {
      startDate,
      endDate,
      focusedDate: constrainValue(focusedDate, minValue, maxValue)
    };
  };
}
function getNextPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  const start = startDate.add(visibleDuration);
  return adjust({
    focusedDate: focusedDate.add(visibleDuration),
    startDate: alignStart(
      constrainStart(focusedDate, start, visibleDuration, locale, minValue, maxValue),
      visibleDuration,
      locale
    )
  });
}
function getPreviousPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  let start = startDate.subtract(visibleDuration);
  return adjust({
    focusedDate: focusedDate.subtract(visibleDuration),
    startDate: alignStart(
      constrainStart(focusedDate, start, visibleDuration, locale, minValue, maxValue),
      visibleDuration,
      locale
    )
  });
}
function getNextRow(focusedDate, startDate, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  if (visibleDuration.days) {
    return getNextPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue);
  }
  if (visibleDuration.weeks || visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: focusedDate.add({ weeks: 1 }),
      startDate
    });
  }
}
function getPreviousRow(focusedDate, startDate, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  if (visibleDuration.days) {
    return getPreviousPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue);
  }
  if (visibleDuration.weeks || visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: focusedDate.subtract({ weeks: 1 }),
      startDate
    });
  }
}
function getSectionStart(focusedDate, startDate, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  if (visibleDuration.days) {
    return adjust({
      focusedDate: startDate,
      startDate
    });
  }
  if (visibleDuration.weeks) {
    return adjust({
      focusedDate: startOfWeek2(focusedDate, locale),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: startOfMonth3(focusedDate),
      startDate
    });
  }
}
function getSectionEnd(focusedDate, startDate, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  const endDate = getEndDate(startDate, visibleDuration);
  if (visibleDuration.days) {
    return adjust({
      focusedDate: endDate,
      startDate
    });
  }
  if (visibleDuration.weeks) {
    return adjust({
      //@ts-expect-error - endOfWeek is loosely typed
      focusedDate: endOfWeek(focusedDate, locale),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: endOfMonth2(focusedDate),
      startDate
    });
  }
}
function getNextSection(focusedDate, startDate, larger, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  if (!larger && !visibleDuration.days) {
    return adjust({
      focusedDate: focusedDate.add(getUnitDuration(visibleDuration)),
      startDate
    });
  }
  if (visibleDuration.days) {
    return getNextPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue);
  }
  if (visibleDuration.weeks) {
    return adjust({
      focusedDate: focusedDate.add({ months: 1 }),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: focusedDate.add({ years: 1 }),
      startDate
    });
  }
}
function getPreviousSection(focusedDate, startDate, larger, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  if (!larger && !visibleDuration.days) {
    return adjust({
      focusedDate: focusedDate.subtract(getUnitDuration(visibleDuration)),
      startDate
    });
  }
  if (visibleDuration.days) {
    return getPreviousPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue);
  }
  if (visibleDuration.weeks) {
    return adjust({
      focusedDate: focusedDate.subtract({ months: 1 }),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: focusedDate.subtract({ years: 1 }),
      startDate
    });
  }
}

// src/parse-date.ts
import { CalendarDateTime, DateFormatter as DateFormatter4 } from "@internationalized/date";
function parseDateString(date, locale, timeZone) {
  const regex = createRegex(locale, timeZone);
  const { year, month, day } = extract(regex, date) ?? {};
  if (year != null && year.length === 4 && month != null && +month <= 12 && day != null && +day <= 31) {
    return new CalendarDateTime(+year, +month, +day);
  }
  const time = Date.parse(date);
  if (!isNaN(time)) {
    const date2 = new Date(time);
    return new CalendarDateTime(date2.getFullYear(), date2.getMonth() + 1, date2.getDate());
  }
}
function createRegex(locale, timeZone) {
  const formatter = new DateFormatter4(locale, { day: "numeric", month: "numeric", year: "numeric", timeZone });
  const parts = formatter.formatToParts(new Date(2e3, 11, 25));
  return parts.map(({ type, value }) => type === "literal" ? value : `((?!=<${type}>)\\d+)`).join("");
}
function extract(pattern, str) {
  const matches = str.match(pattern);
  return pattern.toString().match(/<(.+?)>/g)?.map((group) => {
    const groupMatches = group.match(/<(.+)>/);
    if (!groupMatches || groupMatches.length <= 0) {
      return null;
    }
    return group.match(/<(.+)>/)?.[1];
  }).reduce(
    (acc, curr, index) => {
      if (!curr)
        return acc;
      if (matches && matches.length > index) {
        acc[curr] = matches[index + 1];
      } else {
        acc[curr] = null;
      }
      return acc;
    },
    {}
  );
}
export {
  alignCenter,
  alignDate,
  alignEnd,
  alignStart,
  alignStartDate,
  constrainStart,
  constrainValue,
  formatDate,
  formatRange,
  formatSelectedDate,
  formatVisibleRange,
  getAdjustedDateFn,
  getDayFormatter,
  getDaysInWeek,
  getDecadeRange,
  getEndDate,
  getMonthDays,
  getMonthFormatter,
  getMonthNames,
  getNextDay,
  getNextPage,
  getNextRow,
  getNextSection,
  getPreviousAvailableDate,
  getPreviousDay,
  getPreviousPage,
  getPreviousRow,
  getPreviousSection,
  getSectionEnd,
  getSectionStart,
  getTodayDate,
  getUnitDuration,
  getWeekDays,
  getWeekdayFormats,
  getYearsRange,
  isDateDisabled,
  isDateEqual,
  isDateInvalid,
  isDateOutsideVisibleRange,
  isDateUnavailable,
  isNextVisibleRangeInvalid,
  isPreviousVisibleRangeInvalid,
  isTodayDate,
  parseDateString,
  setCalendar,
  setDate,
  setMonth,
  setYear
};
//# sourceMappingURL=index.mjs.map