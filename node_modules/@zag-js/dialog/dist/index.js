"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  anatomy: () => anatomy,
  connect: () => connect,
  machine: () => machine
});
module.exports = __toCommonJS(src_exports);

// src/dialog.anatomy.ts
var import_anatomy = require("@zag-js/anatomy");
var anatomy = (0, import_anatomy.createAnatomy)("dialog").parts(
  "trigger",
  "backdrop",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
var parts = anatomy.build();

// src/dialog.dom.ts
var import_dom_query = require("@zag-js/dom-query");
var dom = (0, import_dom_query.createScope)({
  getPositionerId: (ctx) => ctx.ids?.positioner ?? `dialog:${ctx.id}:positioner`,
  getBackdropId: (ctx) => ctx.ids?.backdrop ?? `dialog:${ctx.id}:backdrop`,
  getContentId: (ctx) => ctx.ids?.content ?? `dialog:${ctx.id}:content`,
  getTriggerId: (ctx) => ctx.ids?.trigger ?? `dialog:${ctx.id}:trigger`,
  getTitleId: (ctx) => ctx.ids?.title ?? `dialog:${ctx.id}:title`,
  getDescriptionId: (ctx) => ctx.ids?.description ?? `dialog:${ctx.id}:description`,
  getCloseTriggerId: (ctx) => ctx.ids?.closeTrigger ?? `dialog:${ctx.id}:close`,
  getContentEl: (ctx) => dom.getById(ctx, dom.getContentId(ctx)),
  getTriggerEl: (ctx) => dom.getById(ctx, dom.getTriggerId(ctx)),
  getTitleEl: (ctx) => dom.getById(ctx, dom.getTitleId(ctx)),
  getDescriptionEl: (ctx) => dom.getById(ctx, dom.getDescriptionId(ctx))
});

// src/dialog.connect.ts
function connect(state, send, normalize) {
  const ariaLabel = state.context["aria-label"];
  const isOpen = state.matches("open");
  const rendered = state.context.renderedElements;
  return {
    isOpen,
    open() {
      send("OPEN");
    },
    close() {
      send("CLOSE");
    },
    triggerProps: normalize.button({
      ...parts.trigger.attrs,
      dir: state.context.dir,
      id: dom.getTriggerId(state.context),
      "aria-haspopup": "dialog",
      type: "button",
      "aria-expanded": isOpen,
      "data-state": isOpen ? "open" : "closed",
      "aria-controls": dom.getContentId(state.context),
      onClick() {
        send("TOGGLE");
      }
    }),
    backdropProps: normalize.element({
      ...parts.backdrop.attrs,
      dir: state.context.dir,
      hidden: !isOpen,
      id: dom.getBackdropId(state.context),
      "data-state": isOpen ? "open" : "closed"
    }),
    positionerProps: normalize.element({
      ...parts.positioner.attrs,
      dir: state.context.dir,
      id: dom.getPositionerId(state.context),
      style: {
        pointerEvents: isOpen ? void 0 : "none"
      }
    }),
    contentProps: normalize.element({
      ...parts.content.attrs,
      dir: state.context.dir,
      role: state.context.role,
      hidden: !isOpen,
      id: dom.getContentId(state.context),
      tabIndex: -1,
      "data-state": isOpen ? "open" : "closed",
      "aria-modal": true,
      "aria-label": ariaLabel || void 0,
      "aria-labelledby": ariaLabel || !rendered.title ? void 0 : dom.getTitleId(state.context),
      "aria-describedby": rendered.description ? dom.getDescriptionId(state.context) : void 0
    }),
    titleProps: normalize.element({
      ...parts.title.attrs,
      dir: state.context.dir,
      id: dom.getTitleId(state.context)
    }),
    descriptionProps: normalize.element({
      ...parts.description.attrs,
      dir: state.context.dir,
      id: dom.getDescriptionId(state.context)
    }),
    closeTriggerProps: normalize.button({
      ...parts.closeTrigger.attrs,
      dir: state.context.dir,
      id: dom.getCloseTriggerId(state.context),
      type: "button",
      onClick(event) {
        event.stopPropagation();
        send("CLOSE");
      }
    })
  };
}

// src/dialog.machine.ts
var import_aria_hidden = require("@zag-js/aria-hidden");
var import_core = require("@zag-js/core");
var import_dismissable = require("@zag-js/dismissable");
var import_dom_query2 = require("@zag-js/dom-query");
var import_remove_scroll = require("@zag-js/remove-scroll");
var import_utils = require("@zag-js/utils");
var import_focus_trap = require("focus-trap");
function machine(userContext) {
  const ctx = (0, import_utils.compact)(userContext);
  return (0, import_core.createMachine)(
    {
      id: "dialog",
      initial: ctx.open ? "open" : "closed",
      context: {
        role: "dialog",
        renderedElements: {
          title: true,
          description: true
        },
        modal: true,
        trapFocus: true,
        preventScroll: true,
        closeOnInteractOutside: true,
        closeOnEscapeKeyDown: true,
        restoreFocus: true,
        ...ctx
      },
      watch: {
        open: ["toggleVisibility"]
      },
      states: {
        open: {
          entry: ["checkRenderedElements"],
          activities: ["trackDismissableElement", "trapFocus", "preventScroll", "hideContentBelow"],
          on: {
            CLOSE: {
              target: "closed",
              actions: ["invokeOnClose", "restoreFocus"]
            },
            TOGGLE: {
              target: "closed",
              actions: ["invokeOnClose", "restoreFocus"]
            }
          }
        },
        closed: {
          on: {
            OPEN: {
              target: "open",
              actions: ["invokeOnOpen"]
            },
            TOGGLE: {
              target: "open",
              actions: ["invokeOnOpen"]
            }
          }
        }
      }
    },
    {
      activities: {
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom.getContentEl(ctx2);
          return (0, import_dismissable.trackDismissableElement)(getContentEl, {
            defer: true,
            pointerBlocking: ctx2.modal,
            exclude: [dom.getTriggerEl(ctx2)],
            onEscapeKeyDown(event) {
              if (!ctx2.closeOnEscapeKeyDown)
                event.preventDefault();
              else
                send({ type: "CLOSE", src: "escape-key" });
              ctx2.onEscapeKeyDown?.(event);
            },
            onPointerDownOutside(event) {
              if (!ctx2.closeOnInteractOutside)
                event.preventDefault();
              ctx2.onPointerDownOutside?.(event);
            },
            onFocusOutside(event) {
              if (!ctx2.closeOnInteractOutside)
                event.preventDefault();
              ctx2.onFocusOutside?.(event);
            },
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside" });
            }
          });
        },
        preventScroll(ctx2) {
          if (!ctx2.preventScroll)
            return;
          return (0, import_remove_scroll.preventBodyScroll)(dom.getDoc(ctx2));
        },
        trapFocus(ctx2) {
          if (!ctx2.trapFocus || !ctx2.modal)
            return;
          let trap;
          (0, import_dom_query2.nextTick)(() => {
            const contentEl = dom.getContentEl(ctx2);
            if (!contentEl)
              return;
            trap = (0, import_focus_trap.createFocusTrap)(contentEl, {
              document: dom.getDoc(ctx2),
              escapeDeactivates: false,
              preventScroll: true,
              returnFocusOnDeactivate: false,
              fallbackFocus: contentEl,
              allowOutsideClick: true,
              initialFocus: (0, import_utils.runIfFn)(ctx2.initialFocusEl)
            });
            try {
              trap.activate();
            } catch {
            }
          });
          return () => trap?.deactivate();
        },
        hideContentBelow(ctx2) {
          if (!ctx2.modal)
            return;
          const getElements = () => [dom.getContentEl(ctx2)];
          return (0, import_aria_hidden.ariaHidden)(getElements, { defer: true });
        }
      },
      actions: {
        checkRenderedElements(ctx2) {
          (0, import_dom_query2.raf)(() => {
            ctx2.renderedElements.title = !!dom.getTitleEl(ctx2);
            ctx2.renderedElements.description = !!dom.getDescriptionEl(ctx2);
          });
        },
        invokeOnClose(ctx2) {
          ctx2.onOpenChange?.({ open: false });
        },
        invokeOnOpen(ctx2) {
          ctx2.onOpenChange?.({ open: true });
        },
        toggleVisibility(ctx2, _evt, { send }) {
          send({ type: ctx2.open ? "OPEN" : "CLOSE", src: "controlled" });
        },
        restoreFocus(ctx2) {
          if (!ctx2.restoreFocus)
            return;
          (0, import_dom_query2.raf)(() => {
            const el = (0, import_utils.runIfFn)(ctx2.finalFocusEl) ?? dom.getTriggerEl(ctx2);
            el?.focus({ preventScroll: true });
          });
        }
      }
    }
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  anatomy,
  connect,
  machine
});
//# sourceMappingURL=index.js.map